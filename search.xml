<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NachOS源码学习(二)：同步机制]]></title>
    <url>%2F2019%2F05%2F03%2Fnachos2%2F</url>
    <content type="text"><![CDATA[源码部分Synch.cc(h)synch.cc(h)中一个有三个类Semaphore,Lock,Condition： Semaphore，能够通过一个名字和一个值来初始化一个信号量。 P函数的作用类似于sem_wait()，它判断当前线程能否使用临界资源，若不能则将当前线程放入等待队列(value&gt;0),若能(value&gt;0)则将值减一，进入临界区。 V函数的作用类似于sem_pos(),当等待队列不为空时，则取出等待队列队首的线程并将其标注为ReadyToRun,使该线程进入就绪状态，并且初始值加1。 Lock,没有具体的实现，只有基本结构。可以看到它可以用二元信号量来实现。 Aquire()函数就相当于Semphore中的P操作。 Remove()函数相当于Semaphore中的V操作。 Condition,与信号量和锁机制不一样，它是没有值的。当一个线程需要的某种条件没有得到满足时，可以将自己作为一个等待条件变量的线程插入所有等待该条件变量的队列，只要条件一旦得到满足，该线程就会被唤醒继续运行。条件变量总是和锁机制一起使。它的基本方法有Wait、Signal以及BroadCast。所有这些操作必须在当前线程获得一个锁的前提下，而且所有对一个条件变量进行的操作必须建立在同一个锁的前提下。 Wait(Lock *conditionLock) 线程等待条件变量。条件变量的实现Wait()，先关闭中断，将锁释放，然后将当前线程加入等待条件变量的队列，当前线程睡眠。如果被唤醒，需要重新获得锁。 Signal(Lock *conditionLock) 从条件变量的等待队列中唤醒一个等待该条件变量的线程。Signal()操作，如果等待队列非空，则将队列中的一个线程唤醒，加入线程就绪队列。 BroadCast(Lock *conditionLock) 唤醒所有等待该条件变量的线程。源码部分Synchlist.cc(h) synchlist.cc(h)中只有一个类，实现了对队列的互斥访问。Append()函数用于添加一个线程到队尾。Remove()函数用于将队首的线程移出队列。用Lock锁实现了Append()函数与Remove()函数对队列的互斥访问，两者之间不能同时被CPU运行。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>NachOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NachOS源码学习(一)：线程升级]]></title>
    <url>%2F2019%2F05%2F03%2Fnachos1%2F</url>
    <content type="text"><![CDATA[NachOS简介简介 Nachos的全称是“Not Another Completely Heuristic Operating System”，它是一个可修改和跟踪的操作系统教学软件。它给出了一个支持多线程和虚拟存储的操作系统骨架，可让学生在较短的时间内对操作系统中的基本原理和核心算法有一个全面和完整的了解。 NachOS工作机制1.jpg NachOS源码的大体结构2.jpg NachOS源码学习:线程模块理论部分:Nachos 广泛采用线程的概念，是多线程操作系统。线程是Nachos处理机调度的单位，在Nachos中线程分成两类: 系统线程。所谓系统线程是只运行核心代码的线程，它运行在核心态下，并且占用宿主机的资源，系统线程共享Nachos操作系统本身的正文段和数据段；一个系统线程完成一件独立的任务，比如在Nachos网络部分，有一个独立的线程一直监测有无发给自己的数据报。 用户线程。Nachos的另一类线程同Nachos中的用户进程有关。Nachos中用户进程由两部分组成，核心代码部分和用户程序部分。用户进程的进程控制块是线程控制块基础上的扩充。每当系统接收到生成用户进程的请求时，首先生成一个系统线程，进程控制块中有保存线程运行现场的空间，保证线程切换时现场不会丢失。该线程的作用是给用户程序分配虚拟机内存空间，并把用户程序的代码段和数据段装入用户地址空间，然后调用解释器解释执行用户程序；由于Nachos模拟的是一个单机环境，多个用户进程会竞争使用Nachos唯一的处理机资源，所以在Nachos用户进程的进程控制块中增加有虚拟机运行现场空间以及进程的地址空间指针等内容，保证用户进程在虚拟机上的正常运行。系统线程竞争使用宿主机的CPU资源，而用户进程的用户程序部分 竞争使用的是虚拟机的CPU和寄存器。 NachOS线程管理的特点 线程个数没有限制。一般的操作系统，进程的数目是有限的，但是Nachos 中线程数目是无限的。线程的控制结构和系统线程的运行是占用宿主机的。能够开多少线程完全由宿主机条件限制，理论上是无限的。 线程调度简单。启动了时钟中断的情况下，当时钟中断到来时。如果就绪线程队列中有就绪线程，就必须进行线程切换。没有启动时钟中断的情况下，Nachos使用非抢占式调度，即进程在运行过程中不会切换到其它进程运行，除非其主动放弃处理机或者运行结束。 线程数据结构简单。Nachos中线程数据结构定义简单，没用户ID，线程ID，无法根据线程ID实现通信，同步互斥，也没有全局性的线程管理机制。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>NachOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下计算机网络知识笔记(三)]]></title>
    <url>%2F2019%2F04%2F29%2FTransport%20layer%2F</url>
    <content type="text"><![CDATA[Transport layer可靠传输的原理不可靠信道的特征将会决定可靠传输协议的复杂性rdt 只考虑单向的数据传输 使用finite state machine来描述sender,receiver的状态 rdt1.0 只考虑最简单的情况 没有bit error 没有loss packets rdt2.0 可能会发生位的翻转(flip bits) 依然假设包抵达receiver时是有序的，没有丢包的 使用校验和(checksum)来检测bit error 问题：如何恢复错误？ receiver会发送两种包 ACKs NAKs 告诉发送者包有错误 retransmit重传包 rdt2.0的新机制 error detection feedback (control msg) retransmission 还采用了stop and wait的机制 当发送者发送了一个包后就会等待接受者的响应 如果ACK/NAK损坏了呢？ 介绍一种新的sender-to-receiver packet 增加checksum来让发送者检测和恢复，但对丢包无效 发送者在接受到乱码的ACK/NAK的包时重传当前的数据 对于第三种方法，介绍冗余的数据包(duplicate packets) 接受者不知道发送者是否正确的接受了ACK/NAK包 因此不能知道到达的数据包时新的数据还是重传的 解决方案 为每一个包加上sequence number(序号) 只需要添加1-bit的序列号就行了 上述就是rdt2.1 rdt2.2 NAK free 接受者发送上一个正确的包的ACK 为ACK包也加上序号，表明是哪一个包的ACK 冗余的ACK会导致与NAK相同的动作：让发送者重传当前的包 rdt3.0(alternating-bit protocol)比特交替协议 新的假设：data,ACKs可能会丢包，校验和，序列，ACKs,重传还不够帮助检测丢包 approach sender等待ACK合理的时间 如果没有接收到ACK就重传 如果ACK的包只是延迟了 重传就会使接收方收到冗余数据 接收者一定要标明ACK的序号 需要countdown timer倒数计时器 发送者是在传输数据包时就启动计时器，在收到正确的ACK报文时停止计时器 即使是收到了损坏的或者序列号不正确的ACK包，也不重传，只在超时时重传并且重置计时器 rdt3.0性能非常的差stinks,因为一次就传输一个包并且开始等待。stop-and-wait会限制物理资源的使用 RTT是不算传输时间的 改善：Pipelined protocols(流水线协议) 允许发送者有多个，在传输中，未被确认的包 sequence numbers需要增加 发送者/接收者处需要有buffer,来存储已发送但未被确认的包 两种常用的 pipelined protocols go-Back-N,（GBN,回退N步 允许流水线中存在N个未被确认的数据包 接收者采用累计确认(cumulative ack) 如果接收到的包的序列号与累计确认值有gap,那么就不会接收这个包 最早未被确认的数据维护一个定时器 当计时器过期时。需要重传所有的数据包 selective repeat(SR,选择重传 同样允许流水线中存在N个未被确认的数据包 接收者是独立确认每一个包 每个未确认的数据包维护一个定时器 当timer过期时，仅仅重传未被确认的数据包 Go Back N window size N 流水线中允许连续未被确认包(也可以是未发送的)的最大数量 send_base 最早未被确认的包的序列号 nextseqnum 最小的未被使用的序列号 数据包的数量不允许是无限的，因为flow control和congestion control k-bits seq #，tcp是有32-bit的序列号 当sender接收到ACK之后滑动窗口 GBN 发送者必须响应的三种事件 被应用层调用，首先判断nextseqnum是否大于seq_base+N,这代表着window是否已满 若满 将数据返回给应用层 未满 创建数据包，发送 收到ACK，ACK(n) 序列号n即之前的所有数据包都已经被确认了 可能会收到冗余的数据包 超时事件,timeout(n) 重传序列号为n,以及更高序列号的包 GBN 接收者 始终发送序列号最高（及最近发生）的正确接收的数据包的ACK 可能会造成冗余的ACK‘ 对于乱序的包，一律丢掉（丢掉所有损坏，以及不是期待编号的包 sender有buffer,但是receiver没有 Selective Repeat GBN的问题：如果带宽延迟和窗口大小较大会导致很多包重传 只重传那些未确认的包 发送者 也使用window，N个连续的序列号可用 用于已发送，但未确认的包 接收者 独立的确认所有被正确接收的包 缓存接收到的包，以便将其有序的发送给上层 接收者与发送者都有窗口 sender 当有来自上层的数据时，如果有可用的序列号，则发送包 timeout(n),重发包n，并且重启timer ACK(n) in [sendbase,sendbase+n-1] 标志着标志n被接受了 如果n是序列号最小的未确认的包，则接收后需要将窗口移动到下一个未确认包的序列上 receiver pkt n in [rcvbase,rcvbase+N-1] send ACK(n) 如果out-of-order 则放入到buffer中，不做窗口移动 如果in-order 依旧是放入到buffer中去，只不过还要移动窗口，到下一个未被接收(not-yet-received)的包 pkt n in [rcvbase-N,rcvbase-1] send ACK(n) otherwise ignore SR的缺点 当接收到in-order的包的时候，receiver方无法判断是重传的包，还是新数据，它在这两种情况下会做出相同的反应：放入buffer,并移动窗口 summary Checksum(first rdt 2.0 用于检测传输包是否有bit errors Acknowledgment(first rdt 2.0 由接收方传给发送方，表明包已经被正确的接收 Negative Acknowledgment (first rdt 2.0 由接收方传给发送方，表明包未被正确的接收 Sequence Number(first rdt 2.1 接收数据包中序列号的gap或冗余，用来表明包的丢失或冗余 Timer(first rdt 3.0 Window,pipeling(first rdt 3.1 允许多个包被传输且不被ack，发送者的效率高于stop-and-wait的模式 window size由接收者的能力，buffer,level of congestion in the network决定 Connection-oriented transport:TCPOverviews point-to-point 同一个连接中只允许有一个接收者，一个发送者 不支持多播的形式(multicasting reliable,in-order byte steam pipelined(流水线) TCP的congestion,flow control来设置window size full duplex data(全双工数据 同一连接中可以有双向(bi-directional)数据流 MSS:最大报文段长度：传输层能够承载的应用层最大数据长度，不包括传输层头部 connection-oriented 数据交换前通过握手(handshaking)来初始化sender,receiver flow controlled sender will not overwhelm(覆没) receiver TCP报文结构 状态字段 SYN：建立连接 FIN：关闭连接 PSH：有DATA传输 RST：连接重置 URG：紧急数据 seq number(序列号 first byte in segment’s data(首个字节数据的编号 它是通过数据的字节来看的，而不是直接看报文的序列 接收者如何处理乱序的报文？ 留下乱序的字节(放在接收者的buffer中，等待缺失的字节来填补间隙 keeps out-of-order bytes and waits for missing bytes to fill in the gaps (in practice) 接收方与发送方都是随机选择首个sequence number acknowledgements number 不同于rdt3.0 接收方期待从发送方收到的字节数据的序列号 cumulative ACK(TCP采用累积确认 example 1 Host R has received bytes from 0-535from host S, is about to send segment to host S with 536in ACK# field exmaple 2 R has received 0-535, 900-1000, R’s next segment contain 536in ACK# field RTT,timeout TCP如何设置重传时间？ 一定要大于RTT,但RTT也是一个变量 太短：会导致过早timeout,很多不必要的重传 太长：会导致对于报文丢失的反应迟缓 如何估计RTT? SampleRTT 从报文开始传输到接收到ACK为RTT 忽略了重传 SampleRTT也是一个变量所以要去它近几次的平均值，而不只是当前的SampleRTT EstimatedRTT EstimatedRTT=(1-α)EstimatedRTT+αSampleRTT α为exponential weighted moving average 指数加权移动平均值(EWMA) influence of past sample decreases exponentially fast过去样本的影响呈指数级下降 α = 0.125(typical value how to set timeout? 大于等于EstimatedRTT 不能比EstimatedRTT大太多 time interval:EstimatedRTT+saftey margin DevRTT(用于估算：采用RTT偏离来估计RTT的程度 DevRTT= (1-β)DevRTT+ β|SampleRTT-EstimatedRTT| TimeoutInterval= EstimatedRTT+ 4*DevRTT 如果采样RTT值波动较小，那么DevRTT值也越小，反之亦然 可靠传输 TCP基于IP的不可靠服务建立了可靠服务(rdt pipelined segments(流水线报文段，与GBN相似 cumulative acks(累计确认 single retransmission timer(单个重传定时器 触发重传的事件 timeout events(超时事件 duplicate acks(冗余ACK TCP 发送方三个重要事件 收到app层发送来的数据 创建带有序列号的报文段 序列号是报文段的字节流中的第一个字节 timer放在最早未被确认的报文那里 timeout,超时 重传导致超时事件的报文 重启timer 收到ack 累计确认，滑动窗口 如果还有未被确认的报文，就需要启动timer 发送方的重要actions NextSeqNum= NextSeqNum+ length(data) 当超时事件被触发时，仅重传最小序列号，未被确认的数据包 上一点与GBN不同，当GBN协议重传最小序列号及其之后所有未被确认的数据 快速重传 丢包一般是通过冗余的ACK来检测到 当报文出现丢失时，就可能会有很多冗余的ACKs 如果发送方收到了三个相同的ACKs,那么就不用等到超时，立刻进行重传 需要注意的问题 seqNum与Ack都是以字节数为单位，所以ack的时候不能跳着确认，只能确认最大的连续收到的包，否则发送端就以为全部收到了，收到的乱序的包是放在接收者的buffer中等待 当发送方收到ack=n时，会认为前面的包都收到了。所以如果发送了两个ack，但更小的ack没收到，也不需要重传 当接收方收到了乱序的报文时，会立即发送冗余的ACK，指明下一个期待的报文编号 累计确认类似于GBN 接收方缓存乱序包类似于SR flow control 发送方的速率应当慢于接收方交付给应用层的速度 接收方控制着发送方，所以发送方才不会传输太多太快覆没接收方的Buffer LastByteRead:应用层从接收方缓存中读取的最新一个字节的编号 LastByteRcvd:到达接收方缓存最新字节数据的编号 LastByteRcvd-LastByteRead&lt;=RcvBuffer rwnd:接收者缓存中的空闲空间；rwnd=RcvBuffer-[LastByteRcvd-LastByteRead] RcvBuffer通过socket option来设置 接收者通过接收者的rwnd值来限制unacked包的数量，保证了接收者buffer不会overflow TCP连接管理 初始化变量 seq.#s buffers,flow control info three way handshake 用户发送SYN字段给服务端 明确最初的用户序列号 不能传输数据 服务器在接收到SYN之后，回复SYNACK字段 服务器分配buffer和变量 初始化服务器使用的序列 不能传输数据 用户接收到SYNACK之后，返回ACK字段 用户分配buffer和变量 可以包含数据 关闭连接 用户终端发送FIN控制字段给服务器 服务器收到FIN，回复ACK。关闭连接，发送FIN给客户端 注意：ACK与FIN是分开发送的 用户接收到FIN后，进入定时等待，回复ACK 定时等待是为了让TCP客户端重发最后的ACK以防其丢包(如果又收到FIN表示丢包了)，时间通常是30 seconds, 1 minute, and 2 minutes. 服务器接收到ACK,连接关闭 RST字段 如果接收到的TCP报文中的端口号或源IP地址不匹配任何一个接收方的套接字 主机会像该包中源IP地址的地方发送一个RST包，告诉他没有处理该报文段的套接字，不要在重发了 如果是UDP报文，那么主机就发送一个ICMP的数据报 如何扫描目标主机端口号 发送消息 发送一个目标端口号为6789的TCP SYN报文段 接收消息 如果从目的地接收TCP SYN ACK：应用程序正在运行TCP端口6789; 如果从目标接收TCP RST：目标主机未使用TCP端口6789运行，攻击者知道该段到达主机并且未被防火墙阻止。 如果什么都没收到：SYN段可能被防火墙阻止，从未到达目标主机 总结 SYN segment:client initiate a TCP connection FIN segment:client or server (客户端或者服务器端)close the TCP connection RST段：接收端口号或源IP地址与任何正在进行的套接字不匹配的TCP段时。 transport-layer servicesservices 提供app processes间的物理连接 send side:将app层的messages，分成segments再传给network layer rcv side:重组segments为messages,传递给app layer transport vs network layer 传输层 逻辑连接建立在进程之间 依赖，增强了 network layer的服务 网络层 主机间的逻辑连接 best-effort delievery 无法保证报文传输的顺序和数据的完整性 IP是一个不可靠服务 由传输协议提供的服务通常受到底层网络层协议（延迟或带宽）的服务模型的约束，一些服务不包括在内，例如， 可靠的数据传输服务 Protocols reliable, in-order TCP data delivery error checking flow control congestion control connection setup unreliable,unordered UDP data delivery error checking services not available delay guarantees bandwidth guarantees multiplexing and demutiplexing(多路复用与多路分解multiplexing at sender：处理不同套接字的数据，增加transport header(为了后面用于多路分解demultiplexing at receiver： 利用header info将接收到的报文发送到正确的套接字中多路分解中，主机利用IP地址和端口号将报文指向合适的套接字Port number port number是一个16-bit的数字,from 0 to 65535 0 to 1023 well-known port numbers 1024 to 65535 dynamic and/or private ports UDP socket identified: dest IP dest Port TCP socket identified: dest IP dest Port source IP Source Port 今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程UDPFeatures best effort service lost delivered out-of-order to app connectionless sender,receiver之间没有握手 每个UDP报文都独立于其他 used in DNS RIP(Routing Information Protocol SNMP(Simple Network Management Protocol streaming multimedia apps(loss tolerant,rate sensitive reliable transfer over UDP possible but a nontrivial(艰巨) task add reliability at application layer (adding acknowledgment and retransmission mechanisms) application-specific error recovery 为何会有UDP的存在 no congestion control：UDP速度快，很好的适用于real-time applications 没有建立连接：减少延迟 sender,receiver没有连接状态 更小的header size TCP: typical 20 bytes UDP:8 bytes segment header 每个字段都是2 bytes source port dest port length(including header checksum checksum goal:检验是传输的报文中是否存在错误 sender 将包括头部字段的报文内容视为16-bit整数的序列 先带循环进位累加所有序列 累加结果再求反码 checksum被放在udp的checksum field receiver 将所有的16-Bit加起来，包括checksum 查看结果是否等于1111111111111111 note UDP并不会恢复错误 Some implementations of UDP simply discard the damaged segment; others pass the damaged segment with a warning Congestion control的原理太多的数据源太快地发送太多数据，网络无法处理“与流量控制不同！（接收方控制发送方，因此发送方不会让接收方的缓冲区溢出）表现： lost packets(buffer overflow at routers) long delay(queueing in router buffers) 拥塞控制两种常用的方法 端到端拥塞控制(end-end congestion control) 没有网络中显示的反馈 通过终端注意到的loss,delay来推测拥塞 TCP可使用该方法 网络辅助的拥塞控制(network-assisted congestion control) 路由器提供反馈给终端 single bit indicating congestion (SNA, DECbit, TCP/IP ECN, ATM,XCP) router provides explicit rate information for sender to send (ATM ABR) ATM ABR congestion control 特点 ATM(Asynchronous Transfer Mode):异步传输网络，面向虚电路的方式处理包交换 ABR: available bit rate elastic service 弹性服务 如果发送者现在是轻负载(underloaded),那么发送者可以使用可用的带宽 如果发送者发生了拥塞，那么发送者需要节流(throttled)仅维持所保障的最小速率 RM cells(资源管理信元) 由发送方发送，夹杂着数据信元(data cells注意这不是包 传输拥塞相关的信息 提供直接网络反馈(direct network feedback)与经由接收方的网络反馈(feedback via receiver) 前者是当交换器(不是路由器!)检测到了拥塞之后，就直接返回一个RM给发送方 后者是当data cell经由接收方之后，检测data cell中如果存在拥塞信息，则接收方返回给发送方一个RM RM内容信息 bits in RM cell由路由器设置 1 bit NI(no increase):no increase in rate(轻度拥塞) 1 bit CI(congestion indication):严重拥塞 RM cells从接收方返回时，CI/NI数据不变(因为这两个值由交换机设置 two-byte ER(explicit rate,显式速率) 拥堵的交换机可能会减小cell中的ER值 in RM cell one-bit EFCI(显式转发拥塞指示) in data cell 由拥堵的交换机设为1 如果RM单元之前的数据单元设置了EFCI，则接收方在返回的RM单元中设置CI位 congestion controlTCP发送方如何限制流量进入连接的速率？(how does a TCP sender limit the rate at which it sends traffic into its connection?) 拥塞窗口(cwnd) 对于发送方在网络中发送流量的速率施加约束 LastByteSent-LastByteAcked&lt;=min{cwnd,rwnd} 假设receive buffer非常的大，所以rwnd就可以忽略了，方便分析拥塞机制LastByteSent-LastByteAcked&lt;=rwnd 未确认的包的数量的限制间接地限制了sender的发送速率 cwnd是动态的，感知网络拥塞的功能 TCP sending rate 如何计算 考虑丢包和数据包传输延迟可以忽略 初略的计算方法：发送方一次性发送cwnd bytes，等待ACK包一个RTT之后，发送更多的数据 调整cwnd的大小来控制发送速率 rate =cwnd/RTT bytes/sec(约等于) TCP发送方如何察觉自身与目的地之间的路径拥塞？(how does a TCP sender perceive that there is congestion on the path between itself and the destination?) 定义TCP sender丢包事件(loss event) 出现了超时或者是有来自接收方三个冗余的ACKs loss event提供了拥塞指示 acknowledgments触发（或计时）其拥塞窗口大小的增加 TCP是自计时(self-clocking)的协议 作为感知端到端拥塞的功能，发送方应使用什么算法来改变其发送速率？(what algorithm should the sender use to change its send rate as a function of perceived end-to-end congestion?) 算法的三个主要组成部分 slow start(慢启动) MSS(最大报文段长度)：传输层能够承载应用层的最大数据长度 初始化cwnd=MSS,rate=MSS/RTT(约等于) 如果可用的带宽远大于MSS/RTT，则通过每个RTT将cwnd增加1 MSS来缓慢探测带宽(效率低) slow start:当连接开始时，以指数方式（指数）增加速率直到第一个丢失事件发生 一轮RTT，cwnd增加为原来的两倍 发送方每收到一个ACK(第一轮有cwnd个ACK)，cwnd增加1个MSS，一轮增加1个cwnd 初始速度很慢，但是以指数方式快速上升 慢启动指数增长何时结束 当丢包事件(loss event)是由超时事件(timeout event)指示的 ssthresh=cwnd/2;(ssthresh is a state variable Threshold) cwnd set to 1 MSS 回到慢启动状态 cwnd指数增长直到达到ssthresh,超过了(cwnd&gt;=ssthresh)之后就进入到拥塞避免状态(congestion avoidance state) 当丢包事件是由3个重复的ACK指示的 ssthresh=cwnd/2 cwnd=ssthresh+3.MSS 快速重传并进入到快速恢复状态 congestion avoidance(拥塞避免) 不是在每个RTT后将cwnd加倍，TCP采用了更加保守的方式：一轮RTT只增加一个MSS：发送方每收到一个ACK，cwnd增加1个MSS*(MSS/cwnd) 拥塞避免什么时候停止线性增长？ 当丢包事件(loss event)是由超时事件(timeout event)指示的 ssthresh=cwnd/2;(ssthresh is a state variable Threshold) cwnd set to 1 MSS 回到慢启动状态 当丢包事件是由3个重复的ACK指示的 ssthresh=cwnd/2 cwnd=ssthresh+3.MSS 快速重传并进入到快速恢复状态 fast recovery(快速恢复) 对于导致TCP进入快速恢复状态的丢失段的每个重复ACK，cwnd的值增加1 MSS（cwnd = cwnd + MSS）每多余一个ACK就多一个MSS Fast recovery is a recommended, but not required 为什么cwnd= ssthresh+3.MSS 发送方收到三个冗余ACK，意味着有3个数据包离开网络抵达接收方缓存，即网络中减少了3个数据包，因此可以将拥塞窗口扩大。 当丢包事件(loss event)是由超时事件(timeout event)指示的 ssthresh=cwnd/2;(ssthresh is a state variable Threshold) cwnd set to 1 MSS 回到慢启动状态 new ACK event cwnd=sstresh 进入拥塞避免状态]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下计算机网络知识笔记(二)]]></title>
    <url>%2F2019%2F04%2F29%2FApplication%20Layer%2F</url>
    <content type="text"><![CDATA[Application LayerPrinciples of network applicationsarchitecture Client-server server 永远在线 固定的IP Web,FTP,email,Telnet data center for scaling clients 与服务器通信 间断地连接(intermittently) 动态IP 无法直接与彼此通信 peer-to-peer 没有永远在线的服务器 终端之间直接通信 可收缩性(self-scalability):新的peers带来提供服务的能力和需求 peers间断地连接，改变IP地址 性价比更高(cost effective) 主要的挑战 ISP Friendly Security Incentives(激励) hybrid of client-server and P2P 及时消息应用 中心服务 用户在联机时向中央服务器注册其IP地址 用户联系中央服务器以查找好友的IP地址 两个用户之间的聊天是采用P2P Skype VOIP P2P application centralized server(中心服务):找到他人的地址 client-client connection:direct(not through server) 进程通信 同一个主机中，利用进程间通信(IPC) 不同主机 sending process:创建，发送消息 receiving process:接收消息，响应 Define client:初始化通信(client broswer) server:等待连接，开始会话(web server) P2P也可以定义为client-server 套接字寻址过程 进程必须有标识符 IP地址不能作为进程的标识符 标识符包括了IP地址与端口号 App-layer协议定义 type of messages exchanged message syntax(语法),semantics(语义) rules for when&amp;how processes send&amp;respond to messages 还可以定义为公开协议(open protocols)和私有协议(proprietary protocols)如:skype,QQ,Thunder app需要的传输服务 数据完整性(data integrity) 及时性 吞吐量(Throughput) 安全性 UDP/TCP均不提供timing和throughput保证 安全套接层(SSL) TCP/UDP还没有加密，所以引入了SSL 能够提供encrypted connection,data integrity,end-point authentication 在应用层实施 SSL是如何工作的？ Ans:SSL将应用层未加密的数据进行了加密之后在传输给TCP套接字，如果想要使用SSL，那么应用程序中必须包含SSL的代码。 Web and HTTPweb page包括base HTML file 和一些referenced objectsHTTP(超文本传输协议) 步骤 客户端初始化TCP连接(创建套接字),port 80 服务器创建TCP连接 HTTP messages(app-layer) 在客户端与服务器之间交换 TCP连接关闭 特点 stateless protocol 采用TCP HTTP 连接 non-persistent连接 非持续连接:每一个请求/响应对都使用一个独立的TCP连接. 下载多个objects需要多个连接 缺点 established and maintained for eachrequested object, can place a significant burdenon the Web server 必须给分配TCP缓冲区，并且必须在客户端和服务器中保留TCP变量 each object suffers a deliverydelay of more than two RTTs persistent连接 所有的请求/响应对都使用相同的TCP连接. 可以通过客户端，服务器之间的单个TCP连接发送多个对象 优点 当遇到referenced objects的时候，客户端立刻发送请求 所有的referenced object只需要一个RTT default mode of HTTP uses persistent connections with pipelinling (流水线） 第一次http请求时，请求到一个html file，解析时能够找到引用的对象，进而再次发起请求 Round-trip Time(RTT, 返回时间) 一个包从客户端到服务器再返回所需的时间 包括了processing delays,queuing delays, and propagation delays HTTP Respond time 一个RTT来初始化TCP连接 一个RTT用于HTTP请求和响应 file transmission time =2RTT+file transmission time HTTP Request message request line method url version header lines blank lines body lines HTTP respond message status line version status code status message(phrase) header lines blank lines body lines Method types GET: POST: HEAD:asks server to leave requested object out of response (for debugging) PUT:uploads file in entity body to the path specified in URL field (web publishing) DELETE:deletes file specified in the URL field Status code 200 OK,request succeeded, requested object later in this msg 301 Moved Permanently,requested object moved, new location specified later in this msg(Location:) 400 Bad Request,request msg not understood by server 404 Not Found,requested document not found on this server 505 HTTP Version Not Supported Cookies To identify users, many Web sites use cookies (HTTP protocol can not do this!) 四个组成部分 cookie header line of HTTP responsemessage cookie header line in next HTTP request message cookie file kept on user’s host, managed byuser’s browser back-end(后端) database at Web site cookie就是在无状态的http上创建了一个用户会话层来携带状态 Web caches(proxy server 代理服务器) 目标:不使用原始服务器也能满足客户端的请求 使用步骤 用户通过设置代理服务器来访问web 浏览器将所有的HTTP请求发送给proxy server 如果请求对象在缓存中则返回 如果不在,缓存就会到原始服务器中去请求对象,然后将其返回给客户端 代理服务器既是客户端又是服务器,它通常由ISP安装 出现的原因 减少客户端请求的响应时间 reduce traffic on an institution’s access link Conditional GET 问题:驻留在Web缓存中的对象的副本可能是陈旧的 目标:允许Web缓存检查对象是否是最新的,如果缓存是最新的版本,那么原始服务器将不会发送对象 web cache通过If-modified-since:在HTTP请求中指定缓存副本的日期 origin server：如果缓存的副本是最新的，则response不包含任何对象 FTP(the file transfer protocol)client/server model client:初始化传输 server:远程主机 connection(TCP) control connection port 21 浏览远程目录,发送命令 用户会话未过期前control connection 保持开放 out of band带外 data connection port 20 当服务器接收到文件传输指令时打开data connection 当传输完一个文件后,服务器就关闭data connection 服务器打开另一个TCP数据连接以传输另一个文件 FTP服务器维护“状态”：当前目录，早期验证 stateful protocol Why “out-of-band”? Ans: FTP使用了两个并行连接，一个用于发送控制信息，另一个用于发送数据信息。由于控制信息与数据不在同一个TCP连接中传输，所以FTP发送控制信息out-of-band。 FTP Commands 向control channel发送ASCII text USER username PASS password LIST return list of file in current directory RETR filename retrieves file STOR filename stores (puts) file onto remote host FTP return code status code and phrase(as in HTTP) 331 username OK, password required 125 data connection already open;transfer starting 425 can’t open data connection 452 Error writing file Electronic mailthree major components user agents mail servers mailbox包含用户的incoming messages message queue包含将要被发送的邮件消息 simple mail transfer protocol(SMTP) 邮件服务器之间用SMTP协议发送电子邮件 使用TCP传输电子邮件消息，端口25（服务器），持久连接（持久） 直接传输：将服务器（SMTP客户端）发送到接收服务器（SMTP服务器） 消息一定要是7-bit的ASCII码 命令与响应的交互 commands:ASCII text(HELO,MAIL FROM,RCPT TO,DATA,QUIT response:status code and phrase comparison with HTTP SMTP使用persistent connections, stateful protocol, 7-bit ASCII(MIME), CRLF.CRLF来决定消息的结束 similar ASCII command/response interaction status code persistent HTTP与SMTP使用持久连接 different HTTP是拉的协议;SMTP是推的协议 SMTP要求每个消息必须是7-bit ASCII格式;HTTP没有要求 HTTP每个对象对应一个HTTP相应要求;SMTP所有对象放在一个消息里 mail message format 类似邮局之间新建传递规则 header lines To(required) From(required) Subject(optional) 注意 MAIL FROM 是在SMTP中是来自SMTP客户端的消息，用于标识发送到SMTP服务器的邮件的发件人。而From只是邮件中正文的一行。 blank line(CRLF) body(ASCII) 只允许ASCII MIME(多用途互联网邮件扩展) SMTP:发送/存储接收者服务器(push)mail access protocol:从服务器检索(pull) POP3:Post Office Protocol -version3(邮局协议版本3),server port 110 authorization(认证阶段) transaction,client update 特点 stateless protocol POP3不会跨会话传送状态信息 “下载并保留”：不同客户端上的消息副本 IMAP:Internet Mail Access Protocol(Internet邮件访问协议) stateful protocol 能够管理服务器上的文件,更加的复杂 将所有的消息放在服务器上的一个地方 允许用户组织文件夹中的消息 跨会话保持用户状态（与POP3不同） HTTP user agent is Web browser DNSfeature distributed database application-layer-protocol port 53,using UDP DNS services：通常被其他应用层协议使用 - 包括HTTP，SMTP和FTP 域名到IP地址的转换 主机别名(host aliasing),获取主机别名对应的规范主机名及主机IP地址 邮件服务器别名 负载分配(load distribution) centralize DNS的缺点 单点故障(single point of failure) 流量规模大(traffic volume) 维护成本(maintenance) 无扩展性(doesn’t scale) 远距离的集中式数据库(distant centralized database) 分布式层次数据库 根DNS服务器(root DNS server) 13 root name sever 与本地域名服务器(local name server)直接相连 顶级域DNS服务器(TLD, top-level domain) 权威DNS服务器(authoritative DNS sever) organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts can be maintained by organization (e.g. university, company)themselves or service provider 本地DNS服务器(Local DNS name server) 不属于分层结构 也叫作默认名称服务器 能够有本地缓存 是像代理一样的角色，发送请求到分层结构 Resolution example 迭代查询(iterated query) 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。 usual method(常用模式) 递归查询(recursive query) 直接返回一个最终结果给本地DNS服务器 将名称解析的负担放在联系的名称服务器上 层次结构上层的重负荷 如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让本地服务器自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 DNS Records Resource records(RR) format;(Name,value,Type,TTL) Type=A,标准主机名到IP的映射 Name is hostname Value is IP address Type=NS,域的权威域名服务器 Name is domain name(e.g.,foo.com) Value is hostname of authoritative name server for this domain Type=CNAME,别名对应的规范主机名 Name is alias name (别名) for some “canonical”(the real) name (规范名) Value is canonical name (规范名) Type=MX,别名对应的邮件服务器的规范主机名 Name is alias name Value is canonical name (规范名)of a mail server DNS protocol:header section(12 bytes),每个字段是2 bytesnslookup Tool:can send a DNS query to any DNS server (root, TLD, or authoritative)Inserting records into DNS step 1:在域名注册服务机构(DNS registrar)注册域名 互联网名称与数字地址分配机构(ICANN,Internet Corporation for Assigned Names and Numbers)授权域名注册服务机构 提供names, IP addresses of 权威域名服务器(包括primary主要的+secondary辅助的) registrar inserts two RRs into .com TLD server (networkutopia.com, dns1.networkutopia.com, NS)//域的权威DNS服务器名称 (dns1.networkutopia.com, 212.212.212.1, A)//主机名到IP映射 Step 2:enter your authoritative name server(权威DNS服务器)type A record for www.networkuptopia.com; type MX record for mail.networkutopia.com P2P ApplicationsBitTorrent 稀少资源优先(rarest first) 以牙还牙，一个以善意合作为出发点的博弈策略(tit-for-tat every 30 secs: randomly select another peer, starts sending chunks]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下计算机网络知识笔记(一)]]></title>
    <url>%2F2019%2F04%2F29%2FInternet%2F</url>
    <content type="text"><![CDATA[IntroductionWhat’s the Internet?computing devices hosts=end systems commnication links Fiber transmission rate=bandwidth 传输速率的单位是bits/seconds(bps packet switch(device) routers link-layer switches protocol 控制信息的传输和收发 service view commnuication infrastructure(基础设施 提供给app的通信服务 connection-oriented reliable service(TCP connectionless unreliable service(UDP 提供给apps的API Internet vs Intranet Intranet（内联网，内网 私人网络只允许组织内部的人员接入 difference local &amp; private Intranet is more secure and speed same TCP/IP network protocol e-mail &amp; WWW standards network edgenetwork structure network edge 客户端与服务器 servers often in data centers(数据中心 access networks,physical media(接入网络，物理介质 network core the network edge end system(主机 client/server model peer-peer model(对等模型 pptv,thunder,skype access networks and physical media residential access nets(住宅接入网络 DSL(数字用户线路 数据以不同的传输速度传输 0-4KHZ, phone 4-50KHZ, upstream data 50-1MHZ, downstream data DSL Modem(调制解调器 将数字信号调制到模拟载波信号上进行传输，并解调收到的模拟信号以得到数字信息的电子设备 splitter(分离器 分离电话和数据信号，并将数据信号传送到DSL Modem DSLAM(数字用户线路接入复用器 将从不同住宅得到的模拟信号(analog signal)都转为数字信号(digital format) 分离数据和电话信号，将数据发送到internet 一根DSL连线有三根分离的线 电话来电与因特网连接同时共享一根DSL线 Cable(有线电视电缆网络接入 DSL使用的是现有的电话设施，Cable使用的是现有的有线电视设施 HFC(混合光纤同轴电缆 asymmetric(非对称） 子主题 4 frequency division multiplexing(频分多路复用 不同的channels通过不同的频率frequency来传输 不同住宅是共享access network到cable headend, 而不像DSL不同住宅之间单独与central office相连 fiber to the home(光纤入户 光网络终端(ONT)，也叫作光猫，国内大多是路由器与光猫一体 OLT提供了optical和electrical signals之间的转换 splitter能够将一定数量住宅中的ONT汇集到一个共享光纤里去(from home to OLT institutional access network(机构接入网络 Ethernet(以太网 mobile access network(移动接入网络 wireless LANs(无线局域网) wide-area wireless access(广域无线接入网) 蜂窝电话 3G,4G physical media guided media solid media unguided media 空气，外太空，地面频道，卫星频道 twisted pair copper wire(双绞铜线 缠绕是为了减少电子干扰 传输速率可以取决于线的粗细程度和传输者与接收者之间的距离 按屏蔽层分 非屏蔽双绞线(UTP) 屏蔽双绞线(STP) 最常用的以太网电缆：五类线，其最高传送速率为100Mbps，最大网段长100m（CAT5 coaxial cable(同轴电缆) fiber optic cable(光纤电缆) each plus a bit terrestrial radio channels(地面无线电信道) satellite radio channels(卫星无线电信道) Internet structureend system connect to Internet via access ISPsAccess ISPs in turn must be interconnected(互相连接导致了网络结构的复杂由此产生了multiple global ISPsaccess ISPs连接到regional ISP, regional ISP再连接到Tier-1 ISP(global ISP)content provider network(内容提供网络) 运行他们自己的网络以提供服务 key word ISP 互联网服务提供商 IXP 互联网交换中心 peering link Global ISP之间也需要连接 delay.loss.throughput in networksloss and delay how packet arrival rate to link exceeds output link capacity packets queue, wait for turn four-types of packet delay nodal processing delay(节点处理时延,处理包需要的时间) check bit errors determine output link typically&lt; microseconds(微秒) queueing delay(排队时延，排队等待传输) time waiting at output link for transmission depends on congestion level of router typically microseconds to milliseconds transmission delay(传输时延) the amount of time required to transmit(push) all of the packet’s bits into the link d_trans=L/R L: packets length(bits) R:link bandwidth(bps) typically microseconds to milliseconds propagation delay(传播时延) the time required to propagate from the beginning of link to next link to next router d_prop=d/s d:length of physical link s:speed typically milliseconds queueing delay R:transimission rate(bps) L:packet length(bits) a:average packet arrival rate(packets/s) traffic intensity(流量强度=La/R) La/R&gt;1, more work arriving than can be serviced, average delay infinite packet loss queue in buffer has finite capacity packet arriving to full queue dropped lost packet may be retransmitted by previous node, by source end system, ot not at all throughout rate(bits/time unit) at which bits transferred between sender and receiver(单位时间内多少Bit) instantaneous(瞬时的) throughput:rate at given point in time average throughput:rate over longer period of time bottleneck link link on end-end path that constrains end-end throughput the network core(网络核心)circuit-switched networks 资源是需分配，需要预留的 常用于traditional telephone networks network must establish a connection between before send the information, the connection is called a circuit(电路) 除了建立了电路之外，它还预留一个固定的transmission rate 以约定好的transmission rate transfer data circuit segment idle if not used by call(dedicated resources no sharing) two ways FDM(频分多路复用) the link dedicates a frequency band(频段) to each connection for the duration of the connection the width of the band is called bandwidth(带宽) each circuit continuously gets a fraction of the bandwidth TDM(时分多路复用) time is divided into frames(帧) of fixed duration, and each frame is divided in to a fixed number of time slots(时间片) network dedicates one time slot(circuit) in every frame to this connection, 时间片用于传输数据 每个电路在短暂的时间间隔内定期获得所有的带宽 packet-switched networks 资源不需要预留，按需使用(use on demand) hosts将应用层的信息变成packets(分组/数据包) 每一个包都是以最大链路容量传输的 hosts sending function send packets of data(发送数据包) 将message分成一堆长度为L bit 的数据包 以R的传输速率将包传输到可访问的网络 transmission delay:L(bits)/R(bits/sec) store and forward router buffer store the received packet’s bits, wait for all of them, then begin to transmit(forward) to outbound link 所有的包必须在路由器处等待直到包数据完整才能被传输至下一个链路 end-to-end delay NL/R queueing delay each packet switch has multiple links, each link has an output buffer store packets that router is about to send into that link arriving packet must wait in output buffer, finds link busy queuing delays(排队延迟) variable and depend on level of congestion in network buffer space is finite and may be completely full packet loss(丢包) it will occur when buffer is completely full, either the arriving packet or one of the already-queued packets will be dropped,. If arrival rate to link exceeds transmission rate of link for a period of time packets will queue, wait to be transmitted on link congestion will occur at the router, as packets queue in the link’s output buffer before being transmitted onto the link packets can be dropped if memory fills up two key function routing:determines source-destination route taken by packets forwarding: move packets from router’s input to appropriate router output vs circuit better packet switch不适用于实时服务，因为它的variable and unpredictable end-to-end delays packet better 更好的分享transmission capacity simpler, more efficient, and less costly more efficient是因为packet switch允许更多的用户使用network,并且在用户数量较少时performance差不多 packet switch的优缺点 greater for burst data(突发数据) excessive congestion possible packet delay and loss protocols needed for reliable data transfer, congestion control 什么时候使用circuit bandwidth需要得到保障的时候比如audio/video app]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哲学家就餐问题详解]]></title>
    <url>%2F2019%2F04%2F14%2Fdeadlock-problem%2F</url>
    <content type="text"><![CDATA[问题：有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支叉子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的叉子，只有在他拿到两支叉子时才能进餐。进餐完毕，放下叉子又继续思考。 思考题目中明确不允许死锁的发生，所以排除无为而治的方法（鸵鸟算法）与死锁检测。 静态方法（死锁预防）互斥： 需要六把叉子或者是吃饭的时候共享叉子，与题意不符。 保持占有： 一次性拿两把叉子。 抢占： 不符合哲学家的身份。 设定资源访问顺序： 假设第一个哲学家年龄最大，那么第二个和第五个哲学家就要让他先吃。 动态方法（死锁避免）采用银行家算法：哲学家在每次拿动叉子的时候，先进行判断是否会出现死锁，如果可能出现，哲学家就不拿叉子。 解题伪代码方法012345678910111213141516semophore fork[5]=&#123;1&#125;;int i;void philosopher(int i)&#123; while(1)&#123; think(); wait(fork[i]); wait(fork[(i+1) mod 5]) eat(); signal(fork[i]); signal(fork[(i+1) mod 5]) &#125;&#125; int main()&#123; parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4)) &#125; 该方法可以保证不会有两位相邻的哲学家同时进餐。但是如果五位哲学家同时拿走了右边的叉子，他们每一个人都将会因为没有筷子而无期限的等待，造成思锁问题。 方法1思路：至多只允许四位哲学家就餐，由鸽笼原理可以得到至少有一位哲学家能够就餐，所以不会发生死锁。这时，需要引入新的信号量。 12345678910111213141516171819semophore fork[5]=&#123;1&#125;;semophore room=4;int i;void philosopher(int i)&#123; while(1)&#123; think(); wait(room); wait(fork[i]); wait(fork[(i+1) mod 5]) eat(); signal(fork[i]); signal(fork[(i+1) mod 5]) signal(room) &#125;&#125; int main()&#123; parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4)) &#125; 方法2思路：仅当哲学家左右的筷子同时拿起时才允许进餐（一次性请求全部的资源且不允许抢占）。这时，需要引入一个信号量mutex来对取左边叉子和右边叉子时进行互斥保护。 12345678910111213141516171819semaphore mutex=1;semophore fork[5]=&#123;1&#125;;int i;void philosopher(int i)&#123; while(1)&#123; think(); wait(mutex); wait(fork[i]); wait(fork[(i+1) mod 5]) signal(mutex); eat(); signal(fork[i]); signal(fork[(i+1) mod 5]) &#125;&#125; int main()&#123; parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4)) &#125; 方法3思路：设置资源访问顺序，引入两个信号量。 12345678910111213141516171819202122232425262728semophore fork[5]=&#123;1&#125;;semaphore s1=0,s2=0;int i;void philosopher(int i)&#123; while(1)&#123; think(); if((i mod 5)==1)&#123; wait(s1); &#125; if((i mod 5)==4)&#123; wait(s2); &#125; wait(fork[i]); wait(fork[(i+1) mod 5]) eat(); signal(fork[i]); signal(fork[(i+1) mod 5]) if((i mod 5)==0)&#123; signal(s1); signal(s2); &#125; &#125;&#125; int main()&#123; parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4)) &#125; 方法4（银行家算法）]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Deadlock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个常见的python2与python3的兼容问题]]></title>
    <url>%2F2019%2F04%2F08%2Fbug-compatibility%2F</url>
    <content type="text"><![CDATA[字符编码类型 python2默认使用ascii字符编码,但因为ascii只支持数百个字符,不能灵活地满足非英文字符,所以p2也同时支持unicode。但是这样也多了一些标识和转换的麻烦。 python3统一使用unicode字符,节省了开发者时间。 兼容技巧 字符串赋值之前均使用前缀u 引入unicode_literals 导入模块的路径搜索方式 python2导入模块时首先会搜索到当前目录(cwd),若没有,则搜索环境变量路径.这一特性会给开发者带来许多困扰,尤其是自定义模块与系统模块重名的时侯。 python3仅会搜索环境变量路径,当你需要搜索自定义模块时,你可以在包管理模式下将项目路径加入到环境变量中,然后再使用绝对路径和相对路径的方式导入。 兼容技巧 统一使用绝对路径进行自定义模块导入 12345import osimport syspath=os.path.abspath()sys.path.append(path) 如果是使用python2，则可以直接将要导入的文件夹（包）放到当前目录下。]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask jinja2 UnicodeDecodeError 解决方法]]></title>
    <url>%2F2019%2F04%2F08%2Fbug-flask%2F</url>
    <content type="text"><![CDATA[在python2中,当有中文传递给jinja2模板会报如下错误: UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe6 in position 0: ordinal not in range(128) 这个时侯单单在字符串前加u表示为unicode字符已经没有用了，而是需要加上一段代码来搞定： 12345import sys #导入sys模块reload(sys) #在之前import进来时,setdefaultencoding函数在被系统调用后删除了,所以必须重新加载此模块sys.setdefaultencoding(&apos;utf-8&apos;) #修改默认编码方式]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中的SQL注入的思路总结]]></title>
    <url>%2F2019%2F03%2F16%2Fsql0%2F</url>
    <content type="text"><![CDATA[1.拿到题目之后一般是一个登陆框(大概率盲注或者是报错,写脚本跑):1.png 尝试输入用户名(admin)和密码(随意)查看其返回结果这里一般又分为两种: 有返回是密码错误还是用户名错误 只是单一的返回登陆失败 对于第一种情况就可以直接尝试在username之后输入payload的了 判断注入点 按照执行效果判断sql注入类型 利用字典跑一下被过滤的特殊符号和关键字(判断语句一般使用regexp或length(),and或者异或,再或者就是直接输入) payload and length(&#39;关键字&#39;)&gt;0 `^length(&apos;关键字&apos;)&gt;0` 最后利用information_schema爆出库名,表名,字段名以及flag 对于第二种情况就稍微要复杂一些了 可以用burp抓个包,查看一下数据包中是否存在着一些提示内容 尝试一些万能的登陆密码:假设sql语句是:select * from user where username=’$username’ and password=’$password’而我们我发送的数据包中是 username= &amp;password= username=reborn&#39;=&#39;&amp;password=reborn&#39;=&#39; =&gt; select * from user where username=&#39;reborn&#39;=&#39; and password=&#39;reborn&#39;=&#39;=&gt;select * from user where 1 and 1 username=&#39; or 1=1 %23&amp;password=123456 username=admicsfn&#39; union select &#39;25d55ad283aa400af464c76d713c07ad&#39;%23&amp;password=12345678利用不存在的用户再去构造一个密码来进行登陆 查看一下(利用字典)试一试哪一个特殊符号会报错之类的,如果有报错,则考虑报错注入 如果报错的是一些不常见的字符串,那可能就涉及了某些漏洞,比如%报错,就可能是sprintf格式化字符串漏洞 题外话:平时多浏览一些安全网站,去找新出现的漏洞,及时去做一些漏洞复现,与时俱进 2.题目是GET注入(大概率是回显注入) 判断注入点 利用order by判断字段数 union select 1,2,3,...%23判断具体哪个字段存在回显 利用字典跑一下被过滤的特殊符号和关键字(判断语句一般使用length(),and或者异或,再或者就是直接输入) 最后利用information_schema爆出库名,表名,字段名以及flag 如果回显的内容一直不存在变化那就需要考虑盲注了 3.页面直接返回注入结果(insert等其他类型的注入,考虑时间盲注)可以使用&#39; and sleep(5)=&#39;1&#39;=&#39;1或&#39; and sleep(5)=&#39;1&#39;=&#39;1&#39; %23来判断sleep()能否执行]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Django博客网站项目(一)]]></title>
    <url>%2F2019%2F03%2F16%2Fdjango1%2F</url>
    <content type="text"><![CDATA[需要准备的环境 python3以上 创建一个虚拟环境(以兼容不同的Django版本) 创建一个文件夹来专门存放Django(website) 安装Django pip3 install django 打开cmd到website中创建虚拟环境(djangoenv为虚拟环境项目名) cd desktop/website python -m venv djangoenv 继续输入 djangoenv\Scripts\activate就可以将该虚拟环境激活了这是每一次使用虚拟环境都要进行的操作 8.PNG以上虚拟环境就创建好了 创建一个Django项目1django-admin startproject one(项目名) 9.PNG 初始化生成文件的用途 Manage.py 一个在命令行中可以调用的网站管理工具 one文件夹里 init.py 告诉Python这个文件夹是一个模块 settings.py one项目中一些配置 urls.py 网站内各个网址声明 usgi.py web服务器与django项目的接口 新建一个一个Django App123cd onepython manage.py startapp blog(app项目名)再将App添加到settings.py里 10.PNGINSTALLED_APPS默认包括了一下Django自带的应用: django.contrib.admin–管理员站点 django.contrib.auth–认证授权系统 django.contrib.contenttypes–内容类型框架 django.contrib.sessions–会话框架 django.contrib.messages–消息框架 django.contrib.staticfiles–管理静态文件的框架 默认开启的某些应用至少需要一个数据表,所以在使用他们之前要创建一些表 python manage.py migrate 这个命令是用来检查INSTALLED_APPS设置,为其中的每个应用创建需要的数据表(作用到数据库文件) Django的大致运行流程11.png 对于不同路径的响应(一般是在urls.py–blog中修改)在blog文件夹下创建一个新的文件:urls.py用于处理网址的解析,同时在one文件夹下的urls.py中添加一条路径 12urls.py--one path(&apos;&apos;,include(&apos;blog.urls&apos;)), urls.py–one中要添加from django.urls import path,include urls.py–blog中添加from django.urls import path 函数include()允许引用其他的URLconfs.,他会截断与此项相匹配的URL部分,并将剩余的字符串发送到URLconf以供进一步处理.包括其他URL模式时总应该使用include(),admin.site.urls是唯一的例外. 函数path()具有四个参数,两个必须参数:route和view,两个可选参数: kwargs和name一般只填写两个必选参数: route是一个匹配URL的准则.当Django响应一个请求时,他会从urlpatterns的第一项开始,按顺序以此匹配列表中的项,直到找到匹配的项,这些准则不会匹配GET和POST参数或域名.例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3时，也只会尝试匹配 myapp/ path() 参数： view当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。route参数可以有一些特定的格式来处理路径 &lt;slug:blog_link&gt;--slug可以识别字符和数字 &lt;int:blog_id&gt;--int用于识别数字,表示这个网址是个数字存到blog_id这个变量里 &lt;str:blog_title&gt;--str用于识别字符串 13.png 14.png 如上图所示有一个默认的路径http://127.0.0.1:8000/admin/ 编写模型模型是您的数据唯一而且准确的信息来源.它包含您正在存储的数据的重要字段和行为.一般来说,每一个模型都映射一个数据库表 每个模型都是一个python类,这些类继承django.db.models.Model 模型类的每个属性都相当于一个数据库字段 综上,Django正在给你一个自动生成访问数据库的API 19.png 20.png 三个关联模型是为了防止出现重复过多的问题(方便添加数据) 21.png 在models.py文件中建立一个Post模型,还有与之相关联的Category,Tag模型 ForeignKey()–一般用于一对多的模型 ManyToManyField()–一般用于多对多的模型 关联作者模型有现成的直接引入 1from django.contrib.auth.models import User` 22.png 然后,想要在后台直接操作这三个数据,需要现在admin.py中注册一下24.png from .models import Post,Category,Tag–将Post,Category,Tag从models.py中导入 admin.site.register–进行注册 最后每当我们在models做了修改之后都需要执行两个操作 python manage.py makemigrations python manage.py migrate 第一个命令用于检测你对模型文件的修改,并且把修改的部分作为一次迁移(这是一种对于变化的存储形式)第二个命令,在数据库中创建新定义的模型的数据表]]></content>
      <categories>
        <category>Web Development</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入中的绕过]]></title>
    <url>%2F2019%2F03%2F16%2Fsql7%2F</url>
    <content type="text"><![CDATA[###一.对于关键字的绕过 注释符绕过:uni/**/on se/**/lect 大小写绕过:UniOn SeleCt 双关键字绕过:ununionion seselectlect &lt;&gt;绕过:unio&lt;&gt;n sel&lt;&gt;ect(可能是有些网站为了防止xss注入,所以过滤了&lt;&gt;,参照i春秋sql) 对于and,or的绕过其实还可以尝试一下&amp;&amp;,||,异或注入 这里需要注意一点就是or被过滤的时候order,information中的or也被过滤了 ###二.对特殊字符的绕过 对空格的绕过: 两个空格代替一个,用tab键代替空格 `/**/ %20 %09 %0a` 利用空格绕过:很多关键字都可以写成带括号的形式select(),or() 特殊函数中的空格绕过:ascii(mid(xxfrom(1))) ascii(substr(xxfrom(1))) 对单引号的绕过:宽字节 %bf%27 %df%27 %aa%27(争对字符集为GBK时使用十六进制绕过(针对需要输入表名的时候 &#39;user&#39;=&gt;0x7573657273) 对逗号的绕过: substr(x,1,1),mid(x,1,1)=>substr(x from 1 for 1) mid(x from 1 for 1) limit 0,1=> limit 0 offset 1 join(本身是用来连接两个表单的,所以join一定是要放在from后面放表单的位置): union select 1,2 => union select * from (select 1)a join (select 2)b select case when (条件) then (代码1) else (代码2) end 可以对应上if(条件,代码1,代码2) if(substring((select user()) from 1 for 1)='e',sleep(5),1) 可以变为 select case when substring((select user()) from 1 for 1)='e' then sleep(5) else 1 end 等号的绕过: 利用(即不等于号)绕过 利用like绕过 利用greatest()绕过(greatest(a,b)返回较大的那个数) ?id=' or 1 like 1 ?id=' or 1 1 ?id=' union select greatest(substr((select user()),1,1),95) ###三.其他类型的绕过 编码绕过: * 双重url编码:?id=1%252f%252aUNION%252f%252aSELECT%252f%252a1,2,password%252f%252aFROM%252f%252a/Users--+ * unicode编码:'=> %u0037 %u02b9 空格=> %u0020 %uff00 左括号=> %u0028 %uff08 右括号=> %u0029 %uff09 相同字符的绕过:题目中有是可能会出现一种情况: 它不允许出现某个字符串,但是在数据库中又确实存在这个字符串,再加之mysql与php的编码字符集不相同,便可以利用相似的字符将其绕过 1.png 可以参考的题目百度杯十月场look]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他类型注入的详解(5)]]></title>
    <url>%2F2019%2F03%2F16%2Fsql8%2F</url>
    <content type="text"><![CDATA[5.sql异或注入当我们在尝试SQL注入时,发现union,and被完全过滤掉了,就可以考虑使用异或注入。 知识点 异或运算规则: 1^1=0 0^0=0 0^1=1`1^1^1=0 1^1^0=0` 构造payload:&#39;^ascii(mid(database(),1,1)=98)^0 注意这里会多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的 实际应用:Bugku-login3login3]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他类型注入的详解(4)]]></title>
    <url>%2F2019%2F03%2F16%2Fsql5%2F</url>
    <content type="text"><![CDATA[###4.sql约束攻击 ####知识点 数据库字符串比较:在数据库对字符串进行比较时,如果两个字符的长度不一样,则会将较短的字符串末尾填充空格,使两个字符串的长度一致. 比如这两条语句 select * from admin where username=&#39;vampire&#39; select *from admin where username=&#39;vampire &#39; 他们的查询结果是一致的. INSERT截断: 这是数据库的另一个特性,当设计一字段时,我们都必须对其设定一个最大长度,比如CHAR(255),VARCHAR(20),但是当长度超过限制的时候,数据库就会将其截断,只保留限定的长度.(注意这里我们为什么需要insert注入:空格之后一定需要再跟一个或多个任意字符,防止程序在检查用户名是否已经存在时匹配到目标用户) ####限制条件 服务端没有对用户名长度进行限制. 登陆验证的SQL语句没有和用户名和密码一起验证。如果是验证流程是先根据用户名查找出对应的密码，然后再比对密码的话，那么也不能进行利用。因为数据库一般取第一条则是目标用户的记录，那么你传输的密码肯定是和目标用户密码匹配不上的 ####实战:Bugku-login1login1]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他类型注入的详解(2)]]></title>
    <url>%2F2019%2F03%2F16%2Fsql3%2F</url>
    <content type="text"><![CDATA[###2.截断注入 参考题目:wanna see your hat]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入学习总结(一):SQL注入的分类]]></title>
    <url>%2F2019%2F03%2F16%2Fsql1%2F</url>
    <content type="text"><![CDATA[###1.按照执行效果分类 基于布尔盲注,即只会回显true跟false,会根据你的注入信息返回true or false,也就没有了之前的报错信息(substr(),mid(),ascii()) 基于报错的注入,即页面会返回错误的信息,或者把注入的语句的结果直接返回在页面中(updatexml(),floor(),rand(0)*2) 基于时间的盲注,即界面值只有一种,无论输入任何值,返回情况都会按照正常的来处理,而加入特定的时间函数,通过看返回的页面时间差来判断注入的语句是否正确.(sleep().benchmark()) 堆查询注入,即以逗号分开的多条查询语句同时执行,但一般只返回第一条语句的查询结果,所以在第二条语句中进行注入时一般通过时间盲注来获取数据,有些数据库可以执行(pdo),有些不行 回显注入,一般是可以使用union的情况下进行注入 ###2.按照注入点的类型来分类: 数字型(select * from 表名 where id=x),一般的判断语句 x and 1=1页面正常运行,继续进行下一步(x已确认存在数据) x and 1=2页面出错,说明该注入为数字型注入 字符型(select * from 表名 where id=’x’),一般判断的语句: x&#39; and 1=1 %23或 x&#39; and &#39;1&#39;=&#39;1页面正常运行(#号也可能被过滤了导致不成功所以要多试) x&#39; and 1=2 %23或 x&#39; and &#39;1&#39;=&#39;2页面出错,说明该注入为字符型 搜索型(再进行数据搜索的时候没有过滤参数 select * from 表名 where 字段 like ‘%keyword%’) x%&#39; and &#39;1&#39;=&#39;1&#39;%23页面正常运行 x%&#39; and &#39;1&#39;=&#39;2&#39;%23页面出错,说明为一个搜索型的sql注入注:用or也可以进行判断的,不过他更多的用于绕过登录 ###3.按照数据提交的方式 GET注入 POST注入 Cookie注入 XFF等一些需要补充参数的HTTP头部注入]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他类型注入的详解(1)]]></title>
    <url>%2F2019%2F03%2F16%2Fsql2%2F</url>
    <content type="text"><![CDATA[1.二次注入 形成原理:在第一次进入数据库插入数据的时候,仅仅只是使用了addslashes或者是借助get_magic_quotes_gpc对其中的特殊字符进行转义,但是addslashes有一个特点就是虽然在参数前会添加’\’进行转义,但是’\’并不会进入数据库中,再写入数据库时还是保留了原来输入的数据.在下一次需要查询时就直接从数据库中取出了能够构成payload的语句.比如在第一次注入时写入了单引号,就可以形成二次注入。 Tips:一般题目中都会存在登陆注册两种功能(当然也不排除session文件包含) 例子:(sqli-labs less-24) 首先进入搭建好的sqli-labs less-24 注册一个新的账号admin&#39;# 1.png 查看此时数据库中已经多出一个账号了并且特殊符号没有被转义 2.png 我们尝试着登陆进去,会发现可以更改当前用户的密码 3.png 到数据库查看可以发现admin的密码被修改了,而admin’#的密码没有 4.png 我们可以查看pass_change.php的代码,发现修改密码这里的sql语句“UPDATE users SET PASSWORD=’$pass’ where username=’$username’ and password=’$curr_pass’ “;5.png 我们可以看到如果将admin&#39;#带到里面去后:&quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;# and password=&#39;$curr_pass&#39; &quot;;实际上就是:&quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;这里后面的内容都被#注释掉了,这样就是在修改admin的密码了,我们再尝试登陆一下,发现利用admin也可以成功了 6.png]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBC翻转字节攻击]]></title>
    <url>%2F2019%2F03%2F16%2Fsql4%2F</url>
    <content type="text"><![CDATA[知识点:AES的CBC模式加密加密过程: IV:用于随机化加密的字符串 ciphertext_0=Encrypt(Plaintext XOR IV)只用于第一组块 ciphertext_n=Encrypt(Plaintext XOR Ciphertext_N-1)用于除第一组之外的模块 1.png 解密过程: plaintext_0=Decrpt(Ciphertext) XOR IV 只用于第一组块 plaintext_n=Decrpt(Ciphertext) XOR Ciphertext_n-1 2.png CBC攻击攻击发生在解密过程中,实质上就是通过更改上一块的内容,来间接修改明文中的内容,你在密文中改变的字节,只会影响到在下一明文当中,具有相同偏移量的字节.因此,进行cbc攻击仅影响到两个块.主要用途:体现在不知道加密密钥的情况下,通过修改密文,可以间接修改明文 3.png 实际应用:Bugku-login4login4]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
</search>
