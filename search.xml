<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自顶向下计算机网络知识笔记(二)：Application Layer</title>
      <link href="/2019/04/29/Application%20Layer/"/>
      <url>/2019/04/29/Application%20Layer/</url>
      
        <content type="html"><![CDATA[<h1 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h1><h2 id="Principles-of-network-applications"><a href="#Principles-of-network-applications" class="headerlink" title="Principles of network applications"></a>Principles of network applications</h2><h3 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h3><ul><li><p>Client-server</p><ul><li><p>server</p><ul><li>永远在线</li><li>固定的IP</li><li>Web,FTP,email,Telnet</li><li>data center for scaling</li></ul></li><li><p>clients</p><ul><li>与服务器通信</li><li>间断地连接(intermittently)</li><li>动态IP</li><li>无法直接与彼此通信</li></ul></li></ul></li><li><p>peer-to-peer</p><ul><li>没有永远在线的服务器</li><li>终端之间直接通信</li><li>可收缩性(self-scalability):新的peers带来提供服务的能力和需求</li><li>peers间断地连接，改变IP地址</li><li>性价比更高(cost effective)</li><li><p>主要的挑战</p><ul><li>ISP Friendly</li><li>Security</li><li>Incentives(激励)</li></ul></li></ul></li><li><p>hybrid of client-server and P2P</p><ul><li><p>及时消息应用</p><ul><li><p>中心服务</p><ul><li>用户在联机时向中央服务器注册其IP地址</li><li>用户联系中央服务器以查找好友的IP地址</li></ul></li><li><p>两个用户之间的聊天是采用P2P</p></li></ul></li><li><p>Skype</p><ul><li>VOIP P2P application</li><li>centralized server(中心服务):找到他人的地址</li><li>client-client connection:direct(not through server)</li></ul></li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li>同一个主机中，利用进程间通信(IPC)</li><li><p>不同主机</p><ul><li>sending process:创建，发送消息</li><li>receiving process:接收消息，响应</li></ul></li><li><p>Define</p><ul><li>client:初始化通信(client broswer)</li><li>server:等待连接，开始会话(web server)</li></ul></li><li><p>P2P也可以定义为client-server</p></li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h3 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h3><ul><li>进程必须有标识符</li><li>IP地址不能作为进程的标识符</li><li>标识符包括了IP地址与端口号</li></ul><h3 id="App-layer协议定义"><a href="#App-layer协议定义" class="headerlink" title="App-layer协议定义"></a>App-layer协议定义</h3><ul><li>type of messages exchanged</li><li>message syntax(语法),semantics(语义)</li><li>rules for when&amp;how processes send&amp;respond to messages</li><li>还可以定义为公开协议(open protocols)和私有协议(proprietary protocols)如:skype,QQ,Thunder</li></ul><h3 id="app需要的传输服务"><a href="#app需要的传输服务" class="headerlink" title="app需要的传输服务"></a>app需要的传输服务</h3><ul><li>数据完整性(data integrity)</li><li>及时性</li><li>吞吐量(Throughput)</li><li>安全性</li><li>UDP/TCP均不提供timing和throughput保证</li></ul><h3 id="安全套接层-SSL"><a href="#安全套接层-SSL" class="headerlink" title="安全套接层(SSL)"></a>安全套接层(SSL)</h3><ul><li>TCP/UDP还没有加密，所以引入了SSL</li><li>能够提供encrypted connection,data integrity,end-point authentication</li><li>在应用层实施</li><li>SSL是如何工作的？ Ans:SSL将应用层未加密的数据进行了加密之后在传输给TCP套接字，如果想要使用SSL，那么应用程序中必须包含SSL的代码。</li></ul><h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><h3 id="web-page包括base-HTML-file-和一些referenced-objects"><a href="#web-page包括base-HTML-file-和一些referenced-objects" class="headerlink" title="web page包括base HTML file 和一些referenced objects"></a>web page包括base HTML file 和一些referenced objects</h3><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP(超文本传输协议)"></a>HTTP(超文本传输协议)</h3><ul><li><p>步骤</p><ul><li>客户端初始化TCP连接(创建套接字),port 80</li><li>服务器创建TCP连接</li><li>HTTP messages(app-layer) 在客户端与服务器之间交换</li><li>TCP连接关闭</li></ul></li><li><p>特点</p><ul><li>stateless protocol</li><li>采用TCP</li></ul></li><li><p>HTTP 连接</p><ul><li><p>non-persistent连接</p><ul><li>非持续连接:每一个请求/响应对都使用一个独立的TCP连接.</li><li>下载多个objects需要多个连接</li><li><p>缺点</p><ul><li>established and maintained for eachrequested object,</li><li>can place a significant burden<br>on the Web server</li><li>必须给分配TCP缓冲区，并且必须在客户端和服务器中保留TCP变量</li><li>each object suffers a delivery<br>delay of more than two RTTs</li></ul></li></ul></li><li><p>persistent连接</p><ul><li>所有的请求/响应对都使用相同的TCP连接.</li><li>可以通过客户端，服务器之间的单个TCP连接发送多个对象</li><li><p>优点</p><ul><li>当遇到referenced objects的时候，客户端立刻发送请求</li><li>所有的referenced object只需要一个RTT</li></ul></li><li><p>default mode of HTTP uses persistent connections with pipelinling (流水线）</p></li></ul></li><li><p>第一次http请求时，请求到一个html file，解析时能够找到引用的对象，进而再次发起请求</p></li></ul></li><li><p>Round-trip Time(RTT, 返回时间)</p><ul><li>一个包从客户端到服务器再返回所需的时间</li><li>包括了processing delays,queuing delays, and propagation delays</li></ul></li><li><p>HTTP Respond time</p><ul><li>一个RTT来初始化TCP连接</li><li>一个RTT用于HTTP请求和响应</li><li>file transmission time</li><li>=2RTT+file transmission time</li></ul></li><li><p>HTTP Request message</p><ul><li><p>request line</p><ul><li>method</li><li>url</li><li>version</li></ul></li><li><p>header lines</p></li><li>blank lines</li><li>body lines</li></ul></li><li><p>HTTP respond message</p><ul><li><p>status line</p><ul><li>version</li><li>status code</li><li>status message(phrase)</li></ul></li><li><p>header lines</p></li><li>blank lines</li><li>body lines</li></ul></li><li><p>Method types</p><ul><li>GET:</li><li>POST:</li><li>HEAD:asks server to leave requested object out of response (for debugging)</li><li>PUT:uploads file in entity body to the path specified in URL field (web publishing)</li><li>DELETE:deletes file specified in the URL field</li></ul></li><li><p>Status code</p><ul><li>200 OK,request succeeded, requested object later in this msg</li><li>301 Moved Permanently,requested object moved, new location specified later in this msg(Location:)</li><li>400 Bad Request,request msg not understood by server</li><li>404 Not Found,requested document not found on this server</li><li>505 HTTP Version Not Supported</li></ul></li><li><p>Cookies</p><ul><li>To identify users, many Web sites use cookies (HTTP protocol can not do this!)</li><li><p>四个组成部分</p><ul><li>cookie header line of HTTP responsemessage</li><li>cookie header line in next HTTP request message</li><li>cookie file kept on user’s host, managed by<br>user’s browser</li><li>back-end(后端) database at Web site</li></ul></li><li><p>cookie就是在无状态的http上创建了一个用户会话层来携带状态</p></li></ul></li><li><p>Web caches(proxy server 代理服务器)</p><ul><li>目标:不使用原始服务器也能满足客户端的请求</li><li><p>使用步骤</p><ul><li>用户通过设置代理服务器来访问web</li><li>浏览器将所有的HTTP请求发送给proxy server</li><li>如果请求对象在缓存中则返回</li><li>如果不在,缓存就会到原始服务器中去请求对象,然后将其返回给客户端</li></ul></li><li><p>代理服务器既是客户端又是服务器,它通常由ISP安装</p></li><li><p>出现的原因</p><ul><li>减少客户端请求的响应时间</li><li>reduce traffic on an institution’s access link</li></ul></li></ul></li><li><p>Conditional GET</p><ul><li>问题:驻留在Web缓存中的对象的副本可能是陈旧的</li><li>目标:允许Web缓存检查对象是否是最新的,如果缓存是最新的版本,那么原始服务器将不会发送对象</li><li>web cache通过If-modified-since:<date>在HTTP请求中指定缓存副本的日期</date></li><li>origin server：如果缓存的副本是最新的，则response不包含任何对象</li></ul></li></ul><h2 id="FTP-the-file-transfer-protocol"><a href="#FTP-the-file-transfer-protocol" class="headerlink" title="FTP(the file transfer protocol)"></a>FTP(the file transfer protocol)</h2><h3 id="client-server-model"><a href="#client-server-model" class="headerlink" title="client/server model"></a>client/server model</h3><ul><li>client:初始化传输</li><li>server:远程主机</li></ul><h3 id="connection-TCP"><a href="#connection-TCP" class="headerlink" title="connection(TCP)"></a>connection(TCP)</h3><ul><li><p>control connection</p><ul><li>port 21</li><li>浏览远程目录,发送命令</li><li>用户会话未过期前control connection 保持开放</li><li>out of band带外</li></ul></li><li><p>data connection</p><ul><li>port 20</li><li>当服务器接收到文件传输指令时打开data connection</li><li>当传输完一个文件后,服务器就关闭data connection</li><li>服务器打开另一个TCP数据连接以传输另一个文件</li></ul></li><li><p>FTP服务器维护“状态”：当前目录，早期验证</p></li><li>stateful protocol</li><li>Why “out-of-band”? Ans: FTP使用了两个并行连接，一个用于发送控制信息，另一个用于发送数据信息。由于控制信息与数据不在同一个TCP连接中传输，所以FTP发送控制信息out-of-band。</li></ul><h3 id="FTP-Commands"><a href="#FTP-Commands" class="headerlink" title="FTP Commands"></a>FTP Commands</h3><ul><li>向control channel发送ASCII text</li><li>USER username</li><li>PASS password</li><li>LIST return list of file in current directory</li><li>RETR filename retrieves file</li><li>STOR filename stores (puts) file onto remote host</li></ul><h3 id="FTP-return-code"><a href="#FTP-return-code" class="headerlink" title="FTP return code"></a>FTP return code</h3><ul><li>status code and phrase(as in HTTP)</li><li>331 username OK, password required</li><li>125 data connection already open;transfer starting</li><li>425 can’t open data connection</li><li>452 Error writing file</li></ul><h2 id="Electronic-mail"><a href="#Electronic-mail" class="headerlink" title="Electronic mail"></a>Electronic mail</h2><h3 id="three-major-components"><a href="#three-major-components" class="headerlink" title="three major components"></a>three major components</h3><ul><li>user agents</li><li><p>mail servers</p><ul><li>mailbox包含用户的incoming messages</li><li>message queue包含将要被发送的邮件消息</li></ul></li><li><p>simple mail transfer protocol(SMTP)</p><ul><li>邮件服务器之间用SMTP协议发送电子邮件</li><li>使用TCP传输电子邮件消息，端口25（服务器），持久连接（持久）</li><li>直接传输：将服务器（SMTP客户端）发送到接收服务器（SMTP服务器）</li><li>消息一定要是7-bit的ASCII码</li><li><p>命令与响应的交互</p><ul><li>commands:ASCII text(HELO,MAIL FROM,RCPT TO,DATA,QUIT</li><li>response:status code and phrase</li></ul></li></ul></li></ul><h3 id="comparison-with-HTTP"><a href="#comparison-with-HTTP" class="headerlink" title="comparison with HTTP"></a>comparison with HTTP</h3><ul><li>SMTP使用persistent connections, stateful protocol, 7-bit ASCII(MIME), CRLF.CRLF来决定消息的结束</li><li><p>similar</p><ul><li>ASCII command/response</li><li>interaction</li><li>status code</li><li>persistent HTTP与SMTP使用持久连接</li></ul></li><li><p>different</p><ul><li>HTTP是拉的协议;SMTP是推的协议</li><li>SMTP要求每个消息必须是7-bit ASCII格式;HTTP没有要求</li><li>HTTP每个对象对应一个HTTP相应要求;SMTP所有对象放在一个消息里</li></ul></li></ul><h3 id="mail-message-format"><a href="#mail-message-format" class="headerlink" title="mail message format"></a>mail message format</h3><ul><li>类似邮局之间新建传递规则</li><li><p>header lines</p><ul><li>To(required)</li><li>From(required)</li><li>Subject(optional)</li><li>注意 MAIL FROM 是在SMTP中是来自SMTP客户端的消息，用于标识发送到SMTP服务器的邮件的发件人。而From只是邮件中正文的一行。</li></ul></li><li><p>blank line(CRLF)</p></li><li><p>body(ASCII)</p><ul><li>只允许ASCII</li><li>MIME(多用途互联网邮件扩展)</li></ul></li></ul><h3 id="SMTP-发送-存储接收者服务器-push"><a href="#SMTP-发送-存储接收者服务器-push" class="headerlink" title="SMTP:发送/存储接收者服务器(push)"></a>SMTP:发送/存储接收者服务器(push)</h3><h3 id="mail-access-protocol-从服务器检索-pull"><a href="#mail-access-protocol-从服务器检索-pull" class="headerlink" title="mail access protocol:从服务器检索(pull)"></a>mail access protocol:从服务器检索(pull)</h3><ul><li><p>POP3:Post Office Protocol -version3(邮局协议版本3),server port 110</p><ul><li>authorization(认证阶段)</li><li>transaction,client</li><li>update</li><li><p>特点</p><ul><li>stateless protocol</li><li>POP3不会跨会话传送状态信息</li><li>“下载并保留”：不同客户端上的消息副本</li></ul></li></ul></li><li><p>IMAP:Internet Mail Access Protocol(Internet邮件访问协议)</p><ul><li>stateful protocol</li><li>能够管理服务器上的文件,更加的复杂</li><li>将所有的消息放在服务器上的一个地方</li><li>允许用户组织文件夹中的消息</li><li>跨会话保持用户状态（与POP3不同）</li></ul></li><li><p>HTTP</p><ul><li>user agent is Web browser</li></ul></li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><ul><li>distributed database</li><li>application-layer-protocol</li><li>port 53,using UDP</li></ul><h3 id="DNS-services：通常被其他应用层协议使用-包括HTTP，SMTP和FTP"><a href="#DNS-services：通常被其他应用层协议使用-包括HTTP，SMTP和FTP" class="headerlink" title="DNS services：通常被其他应用层协议使用 - 包括HTTP，SMTP和FTP"></a>DNS services：通常被其他应用层协议使用 - 包括HTTP，SMTP和FTP</h3><ul><li>域名到IP地址的转换</li><li>主机别名(host aliasing),获取主机别名对应的规范主机名及主机IP地址</li><li>邮件服务器别名</li><li>负载分配(load distribution)</li></ul><h3 id="centralize-DNS的缺点"><a href="#centralize-DNS的缺点" class="headerlink" title="centralize DNS的缺点"></a>centralize DNS的缺点</h3><ul><li>单点故障(single point of failure)</li><li>流量规模大(traffic volume)</li><li>维护成本(maintenance)</li><li>无扩展性(doesn’t scale)</li><li>远距离的集中式数据库(distant centralized database)</li></ul><h3 id="分布式层次数据库"><a href="#分布式层次数据库" class="headerlink" title="分布式层次数据库"></a>分布式层次数据库</h3><ul><li><p>根DNS服务器(root DNS server)</p><ul><li>13 root name sever</li><li>与本地域名服务器(local name server)直接相连</li></ul></li><li><p>顶级域DNS服务器(TLD, top-level domain)</p></li><li><p>权威DNS服务器(authoritative DNS sever)</p><ul><li>organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts</li><li>can be maintained by organization (e.g. university, company)themselves or service provider</li></ul></li><li><p>本地DNS服务器(Local DNS name server)</p><ul><li>不属于分层结构</li><li>也叫作默认名称服务器</li><li>能够有本地缓存</li><li>是像代理一样的角色，发送请求到分层结构</li></ul></li></ul><h3 id="Resolution-example"><a href="#Resolution-example" class="headerlink" title="Resolution example"></a>Resolution example</h3><ul><li><p>迭代查询(iterated query)</p><ul><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</li><li>usual method(常用模式)</li></ul></li><li><p>递归查询(recursive query)</p><ul><li>直接返回一个最终结果给本地DNS服务器</li><li>将名称解析的负担放在联系的名称服务器上</li><li>层次结构上层的重负荷</li><li>如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让本地服务器自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li></ul></li></ul><h3 id="DNS-Records"><a href="#DNS-Records" class="headerlink" title="DNS Records"></a>DNS Records</h3><ul><li>Resource records(RR) format;(Name,value,Type,TTL)</li><li><p>Type=A,标准主机名到IP的映射</p><ul><li>Name is hostname</li><li>Value is IP address</li></ul></li><li><p>Type=NS,域的权威域名服务器</p><ul><li>Name is domain name(e.g.,foo.com)</li><li>Value is hostname of authoritative name server for this domain</li></ul></li><li><p>Type=CNAME,别名对应的规范主机名</p><ul><li>Name is alias name (别名) for some “canonical”(the real) name (规范名)</li><li>Value is canonical name (规范名)</li></ul></li><li><p>Type=MX,别名对应的邮件服务器的规范主机名</p><ul><li>Name is alias name</li><li>Value is canonical name (规范名)of a mail server</li></ul></li></ul><h3 id="DNS-protocol-header-section-12-bytes-每个字段是2-bytes"><a href="#DNS-protocol-header-section-12-bytes-每个字段是2-bytes" class="headerlink" title="DNS protocol:header section(12 bytes),每个字段是2 bytes"></a>DNS protocol:header section(12 bytes),每个字段是2 bytes</h3><h3 id="nslookup-Tool-can-send-a-DNS-query-to-any-DNS-server-root-TLD-or-authoritative"><a href="#nslookup-Tool-can-send-a-DNS-query-to-any-DNS-server-root-TLD-or-authoritative" class="headerlink" title="nslookup Tool:can send a DNS query to any DNS server (root, TLD, or authoritative)"></a>nslookup Tool:can send a DNS query to any DNS server (root, TLD, or authoritative)</h3><h3 id="Inserting-records-into-DNS"><a href="#Inserting-records-into-DNS" class="headerlink" title="Inserting records into DNS"></a>Inserting records into DNS</h3><ul><li><p>step 1:在域名注册服务机构(DNS registrar)注册域名</p><ul><li>互联网名称与数字地址分配机构(ICANN,Internet Corporation for Assigned Names and Numbers)授权域名注册服务机构</li><li>提供names, IP addresses of 权威域名服务器(包括primary主要的+secondary辅助的)</li><li>registrar inserts two RRs into .com TLD server<ol><li>(networkutopia.com, dns1.networkutopia.com, NS)//域的权威DNS服务器名称</li><li>(dns1.networkutopia.com, 212.212.212.1, A)//主机名到IP映射</li></ol></li></ul></li><li><p>Step 2:enter your authoritative name server(权威DNS服务器)type A record for <a href="http://www.networkuptopia.com" target="_blank" rel="noopener">www.networkuptopia.com</a>; type MX record for mail.networkutopia.com</p></li></ul><h2 id="P2P-Applications"><a href="#P2P-Applications" class="headerlink" title="P2P Applications"></a>P2P Applications</h2><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><ul><li>稀少资源优先(rarest first)</li><li>以牙还牙，一个以善意合作为出发点的博弈策略(tit-for-tat</li><li>every 30 secs: randomly select another peer, starts sending chunks</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自顶向下计算机网络知识笔记(一)：Introduction</title>
      <link href="/2019/04/29/Internet/"/>
      <url>/2019/04/29/Internet/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="What’s-the-Internet"><a href="#What’s-the-Internet" class="headerlink" title="What’s the Internet?"></a>What’s the Internet?</h2><h3 id="computing-devices"><a href="#computing-devices" class="headerlink" title="computing devices"></a>computing devices</h3><ul><li>hosts=end systems</li></ul><h3 id="commnication-links"><a href="#commnication-links" class="headerlink" title="commnication links"></a>commnication links</h3><ul><li>Fiber</li><li><p>transmission rate=bandwidth</p><ul><li>传输速率的单位是bits/seconds(bps</li></ul></li></ul><h3 id="packet-switch-device"><a href="#packet-switch-device" class="headerlink" title="packet switch(device)"></a>packet switch(device)</h3><ul><li>routers</li><li>link-layer switches</li></ul><h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><ul><li>控制信息的传输和收发</li></ul><h3 id="service-view"><a href="#service-view" class="headerlink" title="service view"></a>service view</h3><ul><li><p>commnuication infrastructure(基础设施</p><ul><li><p>提供给app的通信服务</p><ul><li>connection-oriented reliable service(TCP</li><li>connectionless unreliable service(UDP</li></ul></li><li><p>提供给apps的API</p></li></ul></li></ul><h3 id="Internet-vs-Intranet"><a href="#Internet-vs-Intranet" class="headerlink" title="Internet vs Intranet"></a>Internet vs Intranet</h3><ul><li><p>Intranet（内联网，内网</p><ul><li>私人网络只允许组织内部的人员接入</li></ul></li><li><p>difference</p><ul><li>local &amp; private</li><li>Intranet is more secure and speed</li></ul></li><li><p>same</p><ul><li>TCP/IP network protocol</li><li>e-mail &amp; WWW standards</li></ul></li></ul><h2 id="network-edge"><a href="#network-edge" class="headerlink" title="network edge"></a>network edge</h2><h3 id="network-structure"><a href="#network-structure" class="headerlink" title="network structure"></a>network structure</h3><ul><li><p>network edge</p><ul><li>客户端与服务器</li><li>servers often in data centers(数据中心</li></ul></li><li><p>access networks,physical media(接入网络，物理介质</p></li><li>network core</li></ul><h3 id="the-network-edge"><a href="#the-network-edge" class="headerlink" title="the network edge"></a>the network edge</h3><ul><li>end system(主机</li><li>client/server model</li><li><p>peer-peer model(对等模型</p><ul><li>pptv,thunder,skype</li></ul></li></ul><h3 id="access-networks-and-physical-media"><a href="#access-networks-and-physical-media" class="headerlink" title="access networks and physical media"></a>access networks and physical media</h3><ul><li><p>residential access nets(住宅接入网络</p><ul><li><p>DSL(数字用户线路</p><ul><li><p>数据以不同的传输速度传输</p><ul><li>0-4KHZ, phone</li><li>4-50KHZ, upstream data</li><li>50-1MHZ, downstream data</li></ul></li><li><p>DSL Modem(调制解调器</p><ul><li>将数字信号调制到模拟载波信号上进行传输，并解调收到的模拟信号以得到数字信息的电子设备</li></ul></li><li><p>splitter(分离器</p><ul><li>分离电话和数据信号，并将数据信号传送到DSL Modem</li></ul></li><li><p>DSLAM(数字用户线路接入复用器</p><ul><li>将从不同住宅得到的模拟信号(analog signal)都转为数字信号(digital format)</li><li>分离数据和电话信号，将数据发送到internet</li></ul></li><li><p>一根DSL连线有三根分离的线</p></li><li>电话来电与因特网连接同时共享一根DSL线</li></ul></li><li><p>Cable(有线电视电缆网络接入</p><ul><li>DSL使用的是现有的电话设施，Cable使用的是现有的有线电视设施</li><li><p>HFC(混合光纤同轴电缆</p><ul><li>asymmetric(非对称）</li></ul></li><li><p>子主题 4</p></li><li><p>frequency division multiplexing(频分多路复用</p><ul><li>不同的channels通过不同的频率frequency来传输</li></ul></li><li><p>不同住宅是共享access network到cable headend, 而不像DSL不同住宅之间单独与central office相连</p></li></ul></li><li><p>fiber to the home(光纤入户</p><ul><li>光网络终端(ONT)，也叫作光猫，国内大多是路由器与光猫一体</li><li>OLT提供了optical和electrical signals之间的转换</li><li>splitter能够将一定数量住宅中的ONT汇集到一个共享光纤里去(from home to OLT</li></ul></li></ul></li><li><p>institutional access network(机构接入网络</p><ul><li>Ethernet(以太网</li></ul></li><li><p>mobile access network(移动接入网络</p><ul><li>wireless LANs(无线局域网)</li><li><p>wide-area wireless access(广域无线接入网)</p><ul><li>蜂窝电话</li><li>3G,4G</li></ul></li></ul></li><li><p>physical media</p><ul><li><p>guided media</p><ul><li>solid media</li></ul></li><li><p>unguided media</p><ul><li>空气，外太空，地面频道，卫星频道</li></ul></li><li><p>twisted pair copper wire(双绞铜线</p><ul><li>缠绕是为了减少电子干扰</li><li>传输速率可以取决于线的粗细程度和传输者与接收者之间的距离</li><li><p>按屏蔽层分</p><ul><li>非屏蔽双绞线(UTP)</li><li>屏蔽双绞线(STP)</li></ul></li><li><p>最常用的以太网电缆：五类线，其最高传送速率为100Mbps，最大网段长100m（CAT5</p></li></ul></li><li><p>coaxial cable(同轴电缆)</p></li><li><p>fiber optic cable(光纤电缆)</p><ul><li>each plus a bit</li></ul></li><li><p>terrestrial radio channels(地面无线电信道)</p></li><li>satellite radio channels(卫星无线电信道)</li></ul></li></ul><h2 id="Internet-structure"><a href="#Internet-structure" class="headerlink" title="Internet structure"></a>Internet structure</h2><h3 id="end-system-connect-to-Internet-via-access-ISPs"><a href="#end-system-connect-to-Internet-via-access-ISPs" class="headerlink" title="end system connect to Internet via access ISPs"></a>end system connect to Internet via access ISPs</h3><h3 id="Access-ISPs-in-turn-must-be-interconnected-互相连接"><a href="#Access-ISPs-in-turn-must-be-interconnected-互相连接" class="headerlink" title="Access ISPs in turn must be interconnected(互相连接"></a>Access ISPs in turn must be interconnected(互相连接</h3><h3 id="导致了网络结构的复杂"><a href="#导致了网络结构的复杂" class="headerlink" title="导致了网络结构的复杂"></a>导致了网络结构的复杂</h3><h3 id="由此产生了multiple-global-ISPs"><a href="#由此产生了multiple-global-ISPs" class="headerlink" title="由此产生了multiple global ISPs"></a>由此产生了multiple global ISPs</h3><h3 id="access-ISPs连接到regional-ISP-regional-ISP再连接到Tier-1-ISP-global-ISP"><a href="#access-ISPs连接到regional-ISP-regional-ISP再连接到Tier-1-ISP-global-ISP" class="headerlink" title="access ISPs连接到regional ISP, regional ISP再连接到Tier-1 ISP(global ISP)"></a>access ISPs连接到regional ISP, regional ISP再连接到Tier-1 ISP(global ISP)</h3><h3 id="content-provider-network-内容提供网络"><a href="#content-provider-network-内容提供网络" class="headerlink" title="content provider network(内容提供网络)"></a>content provider network(内容提供网络)</h3><ul><li>运行他们自己的网络以提供服务</li></ul><h3 id="key-word"><a href="#key-word" class="headerlink" title="key word"></a>key word</h3><ul><li><p>ISP</p><ul><li>互联网服务提供商</li></ul></li><li><p>IXP</p><ul><li>互联网交换中心</li></ul></li><li><p>peering link</p><ul><li>Global ISP之间也需要连接</li></ul></li></ul><h2 id="delay-loss-throughput-in-networks"><a href="#delay-loss-throughput-in-networks" class="headerlink" title="delay.loss.throughput in networks"></a>delay.loss.throughput in networks</h2><h3 id="loss-and-delay"><a href="#loss-and-delay" class="headerlink" title="loss and delay"></a>loss and delay</h3><ul><li><p>how</p><ul><li>packet arrival rate to link exceeds output link capacity</li><li>packets queue, wait for turn</li></ul></li><li><p>four-types of packet delay</p><ul><li><p>nodal processing delay(节点处理时延,处理包需要的时间)</p><ul><li>check bit errors</li><li>determine output link</li><li>typically&lt; microseconds(微秒)</li></ul></li><li><p>queueing delay(排队时延，排队等待传输)</p><ul><li>time waiting at output link for transmission</li><li>depends on congestion level of router</li><li>typically microseconds to milliseconds</li></ul></li><li><p>transmission delay(传输时延)</p><ul><li>the amount of time required to transmit(push) all of the packet’s bits into the link</li><li><p>d_trans=L/R</p><ul><li>L: packets length(bits)</li><li>R:link bandwidth(bps)</li><li>typically microseconds to milliseconds</li></ul></li></ul></li><li><p>propagation delay(传播时延)</p><ul><li>the time required to propagate from the beginning of link to next link to next router</li><li><p>d_prop=d/s</p><ul><li>d:length of physical link</li><li>s:speed</li></ul></li><li><p>typically milliseconds</p></li></ul></li></ul></li><li><p>queueing delay</p><ul><li>R:transimission rate(bps)</li><li>L:packet length(bits)</li><li>a:average packet arrival rate(packets/s)</li><li>traffic intensity(流量强度=La/R)</li><li>La/R&gt;1, more work arriving than can be serviced, average delay infinite</li></ul></li><li><p>packet loss</p><ul><li>queue in buffer has finite capacity</li><li>packet arriving to full queue dropped</li><li>lost packet may be retransmitted by previous node, by source end system, ot not at all</li></ul></li><li><p>throughout</p><ul><li>rate(bits/time unit) at which bits transferred between sender and receiver(单位时间内多少Bit)</li><li>instantaneous(瞬时的) throughput:rate at given point in time</li><li>average throughput:rate over longer period of time</li><li><p>bottleneck link</p><ul><li>link on end-end path that constrains end-end throughput</li></ul></li></ul></li></ul><h2 id="the-network-core-网络核心"><a href="#the-network-core-网络核心" class="headerlink" title="the network core(网络核心)"></a>the network core(网络核心)</h2><h3 id="circuit-switched-networks"><a href="#circuit-switched-networks" class="headerlink" title="circuit-switched networks"></a>circuit-switched networks</h3><ul><li>资源是需分配，需要预留的</li><li>常用于traditional telephone networks</li><li>network must establish a connection between before send the information, the connection is called a circuit(电路)</li><li>除了建立了电路之外，它还预留一个固定的transmission rate</li><li>以约定好的transmission rate transfer data</li><li>circuit segment idle if not used by call(dedicated resources no sharing)</li><li><p>two ways</p><ul><li><p>FDM(频分多路复用)</p><ul><li>the link dedicates a frequency band(频段) to each connection for the duration of the connection</li><li>the width of the band is called bandwidth(带宽)</li><li>each circuit continuously gets a fraction of the bandwidth</li></ul></li><li><p>TDM(时分多路复用)</p><ul><li>time is divided into frames(帧) of fixed duration, and each frame is divided in to a fixed number of time slots(时间片)</li><li>network dedicates one time slot(circuit) in every frame to this connection, 时间片用于传输数据</li><li>每个电路在短暂的时间间隔内定期获得所有的带宽</li></ul></li></ul></li></ul><h3 id="packet-switched-networks"><a href="#packet-switched-networks" class="headerlink" title="packet-switched networks"></a>packet-switched networks</h3><ul><li>资源不需要预留，按需使用(use on demand)</li><li>hosts将应用层的信息变成packets(分组/数据包)</li><li>每一个包都是以最大链路容量传输的</li><li><p>hosts sending function</p><ul><li>send packets of data(发送数据包)</li><li>将message分成一堆长度为L bit 的数据包</li><li>以R的传输速率将包传输到可访问的网络</li><li>transmission delay:L(bits)/R(bits/sec)</li></ul></li><li><p>store and forward</p><ul><li>router buffer store the received packet’s bits, wait for all of them, then begin to transmit(forward) to outbound link</li><li>所有的包必须在路由器处等待直到包数据完整才能被传输至下一个链路</li><li><p>end-to-end delay</p><ul><li>NL/R</li></ul></li></ul></li><li><p>queueing delay</p><ul><li><p>each packet switch has multiple links, each link has an output buffer</p><ul><li>store packets that router is about to send into that link</li></ul></li><li><p>arriving packet must wait in output buffer, finds link busy</p></li><li><p>queuing delays(排队延迟)</p><ul><li><p>variable and depend on level of congestion in  network</p><ul><li>buffer space is finite and may be completely full</li></ul></li></ul></li><li><p>packet loss(丢包)</p><ul><li>it will occur when buffer is completely full, either the arriving packet or one of the already-queued packets will be dropped,.</li></ul></li><li><p>If arrival rate to link exceeds transmission rate of link for a period of time</p><ul><li>packets will queue, wait to be transmitted on link</li><li>congestion will occur at the router, as packets queue in the link’s output buffer before being transmitted onto the link</li><li>packets can be dropped if memory fills up</li></ul></li></ul></li><li><p>two key function</p><ul><li>routing:determines source-destination route taken by packets</li><li>forwarding: move packets from router’s input to appropriate router output</li></ul></li></ul><h3 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h3><ul><li><p>circuit better</p><ul><li>packet switch不适用于实时服务，因为它的variable and unpredictable end-to-end delays</li></ul></li><li><p>packet better</p><ul><li>更好的分享transmission capacity</li><li>simpler, more efficient, and less costly</li><li>more efficient是因为packet switch允许更多的用户使用network,并且在用户数量较少时performance差不多</li></ul></li></ul><h3 id="packet-switch的优缺点"><a href="#packet-switch的优缺点" class="headerlink" title="packet switch的优缺点"></a>packet switch的优缺点</h3><ul><li>greater for burst data(突发数据)</li><li><p>excessive congestion possible</p><ul><li>packet delay and loss</li><li>protocols needed for reliable data transfer, congestion control</li></ul></li></ul><h3 id="什么时候使用circuit"><a href="#什么时候使用circuit" class="headerlink" title="什么时候使用circuit"></a>什么时候使用circuit</h3><ul><li>bandwidth需要得到保障的时候比如audio/video app</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/29/Transport%20layer/"/>
      <url>/2019/04/29/Transport%20layer/</url>
      
        <content type="html"><![CDATA[<h1 id="Transport-layer"><a href="#Transport-layer" class="headerlink" title="Transport layer"></a>Transport layer</h1><h2 id="可靠传输的原理"><a href="#可靠传输的原理" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h2><h3 id="不可靠信道的特征将会决定可靠传输协议的复杂性"><a href="#不可靠信道的特征将会决定可靠传输协议的复杂性" class="headerlink" title="不可靠信道的特征将会决定可靠传输协议的复杂性"></a>不可靠信道的特征将会决定可靠传输协议的复杂性</h3><h3 id="rdt"><a href="#rdt" class="headerlink" title="rdt"></a>rdt</h3><ul><li>只考虑单向的数据传输</li><li>使用finite state machine来描述sender,receiver的状态</li><li><p>rdt1.0</p><ul><li><p>只考虑最简单的情况</p><ul><li>没有bit error</li><li>没有loss packets</li></ul></li></ul></li><li><p>rdt2.0</p><ul><li><p>可能会发生位的翻转(flip bits)</p><ul><li>依然假设包抵达receiver时是有序的，没有丢包的</li><li>使用校验和(checksum)来检测bit error</li><li><p>问题：如何恢复错误？</p><ul><li><p>receiver会发送两种包</p><ul><li>ACKs</li><li><p>NAKs</p><ul><li>告诉发送者包有错误</li><li>retransmit重传包</li></ul></li></ul></li></ul></li><li><p>rdt2.0的新机制</p><ul><li>error detection</li><li>feedback (control msg)</li><li>retransmission</li></ul></li><li><p>还采用了stop and wait的机制</p><ul><li>当发送者发送了一个包后就会等待接受者的响应</li></ul></li><li><p>如果ACK/NAK损坏了呢？</p><ul><li>介绍一种新的sender-to-receiver packet</li><li>增加checksum来让发送者检测和恢复，但对丢包无效</li><li>发送者在接受到乱码的ACK/NAK的包时重传当前的数据</li></ul></li><li><p>对于第三种方法，介绍冗余的数据包(duplicate packets)</p><ul><li>接受者不知道发送者是否正确的接受了ACK/NAK包</li><li>因此不能知道到达的数据包时新的数据还是重传的</li></ul></li><li><p>解决方案</p><ul><li>为每一个包加上sequence number(序号)</li><li>只需要添加1-bit的序列号就行了</li><li>上述就是rdt2.1</li><li>当ack包丢失时，rdt2.1会造成死锁的问题</li></ul></li><li><p>rdt2.2 NAK free</p><ul><li>接受者发送上一个正确的包的ACK</li><li>为ACK包也加上序号，表明是哪一个包的ACK</li><li>冗余的ACK会导致与NAK相同的动作：让发送者重传当前的包</li><li>可以解决rdt2.1的死锁问题。</li></ul></li></ul></li></ul></li><li><p>rdt3.0(alternating-bit protocol)比特交替协议</p><ul><li>新的假设：data,ACKs可能会丢包，校验和，序列，ACKs,重传还不够帮助检测丢包</li><li><p>approach</p><ul><li>sender等待ACK合理的时间</li><li>如果没有接收到ACK就重传</li><li><p>如果ACK的包只是延迟了</p><ul><li>重传就会使接收方收到冗余数据</li><li>接收者一定要标明ACK的序号</li></ul></li><li><p>需要countdown timer倒数计时器</p><ul><li>发送者是在传输数据包时就启动计时器，在收到正确的ACK报文时停止计时器</li></ul></li></ul></li><li><p>即使是收到了损坏的或者序列号不正确的ACK包，也不重传，只在超时时重传并且重置计时器</p></li><li>rdt3.0性能非常的差stinks,因为一次就传输一个包并且开始等待。stop-and-wait会限制物理资源的使用</li><li>rdt3.0可以不需要ack的序列号，因为序列号如果不对，则接收方将直接忽略，只有等到超时，且没有接收到正确的ack时，才会重传。</li><li>RTT是不算传输时间的</li></ul></li><li><p>改善：Pipelined protocols(流水线协议)</p><ul><li>允许发送者有多个，在传输中，未被确认的包</li><li>sequence numbers需要增加</li><li>发送者/接收者处需要有buffer,来存储已发送但未被确认的包</li></ul></li><li><p>两种常用的 pipelined protocols</p><ul><li><p>Go-Back-N,（GBN,回退N步</p><ul><li>允许流水线中存在N个未被确认的数据包</li><li><p>接收者采用累计确认(cumulative ack)</p><ul><li>如果接收到的包的序列号与累计确认值有gap,那么就不会接收这个包</li></ul></li><li><p>最早未被确认的数据维护一个定时器</p></li><li>当计时器过期时。需要重传所有的数据包</li></ul></li><li><p>Selective Repeat(SR,选择重传</p><ul><li>同样允许流水线中存在N个未被确认的数据包</li><li>接收者是独立确认每一个包</li><li>每个未确认的数据包维护一个定时器</li><li>当timer过期时，仅仅重传未被确认的数据包</li></ul></li></ul></li></ul><h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go Back N"></a>Go Back N</h3><ul><li><p>window size N</p><ul><li>流水线中允许连续未被确认包(也可以是未发送的)的最大数量</li></ul></li><li><p>send_base</p><ul><li>最早未被确认的包的序列号</li></ul></li><li><p>nextseqnum</p><ul><li>最小的未被使用的序列号</li></ul></li><li><p>数据包的数量不允许是无限的，因为flow control和congestion control</p></li><li>k-bits seq #，tcp是有32-bit的序列号</li><li>当sender接收到ACK之后滑动窗口</li><li><p>GBN 发送者必须响应的三种事件</p><ul><li><p>被应用层调用，首先判断nextseqnum是否大于seq_base+N,这代表着window是否已满</p><ul><li><p>若满</p><ul><li>将数据返回给应用层</li></ul></li><li><p>未满</p><ul><li>创建数据包，发送</li></ul></li></ul></li><li><p>收到ACK，ACK(n)</p><ul><li>序列号n即之前的所有数据包都已经被确认了</li><li>可能会收到冗余的数据包</li></ul></li><li><p>超时事件,timeout(n)</p><ul><li>重传序列号为n,以及更高序列号的包</li></ul></li></ul></li><li><p>GBN 接收者</p><ul><li><p>始终发送序列号最高（及最近发生）的正确接收的数据包的ACK</p><ul><li>可能会造成冗余的ACK‘</li></ul></li><li><p>对于乱序的包，一律丢掉（丢掉所有损坏，以及不是期待编号的包</p></li><li>sender有buffer,但是receiver没有</li></ul></li></ul><h3 id="Selective-Repeat"><a href="#Selective-Repeat" class="headerlink" title="Selective Repeat"></a>Selective Repeat</h3><ul><li>GBN的问题：如果带宽延迟和窗口大小较大会导致很多包重传</li><li>只重传那些未确认的包</li><li><p>发送者</p><ul><li>也使用window，N个连续的序列号可用</li><li>用于已发送，但未确认的包</li></ul></li><li><p>接收者</p><ul><li>独立的确认所有被正确接收的包</li><li>缓存接收到的包，以便将其有序的发送给上层</li></ul></li><li><p>接收者与发送者都有窗口</p><ul><li><p>sender</p><ul><li>当有来自上层的数据时，如果有可用的序列号，则发送包</li><li>timeout(n),重发包n，并且重启timer</li><li><p>ACK(n) in [sendbase,sendbase+n-1]</p><ul><li>标志着标志n被接受了</li><li>如果n是序列号最小的未确认的包，则接收后需要将窗口移动到下一个未确认包的序列上</li></ul></li></ul></li><li><p>receiver</p><ul><li><p>pkt n in [rcvbase,rcvbase+N-1]</p><ul><li>send ACK(n)</li><li><p>如果out-of-order</p><ul><li>则放入到buffer中，不做窗口移动</li></ul></li><li><p>如果in-order</p><ul><li>依旧是放入到buffer中去，只不过还要移动窗口，到下一个未被接收(not-yet-received)的包</li></ul></li></ul></li><li><p>pkt n in [rcvbase-N,rcvbase-1]</p><ul><li>send ACK(n)</li></ul></li><li><p>otherwise</p><ul><li>ignore</li></ul></li></ul></li></ul></li><li><p>SR的缺点</p><ul><li>当接收到in-order的包的时候，receiver方无法判断是重传的包，还是新数据，它在这两种情况下会做出相同的反应：放入buffer,并移动窗口</li></ul></li></ul><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul><li><p>Checksum(first rdt 2.0</p><ul><li>用于检测传输包是否有bit errors</li></ul></li><li><p>Acknowledgment(first rdt 2.0</p><ul><li>由接收方传给发送方，表明包已经被正确的接收</li></ul></li><li><p>Negative Acknowledgment (first rdt 2.0</p><ul><li>由接收方传给发送方，表明包未被正确的接收</li></ul></li><li><p>Sequence Number(first rdt 2.1</p><ul><li>接收数据包中序列号的gap或冗余，用来表明包的丢失或冗余</li></ul></li><li><p>Timer(first rdt 3.0</p></li><li><p>Window,pipeling(first rdt 3.1</p><ul><li>允许多个包被传输且不被ack，发送者的效率高于stop-and-wait的模式</li><li>window size由接收者的能力，buffer,level of congestion in the network决定</li></ul></li></ul><h2 id="Connection-oriented-transport-TCP"><a href="#Connection-oriented-transport-TCP" class="headerlink" title="Connection-oriented transport:TCP"></a>Connection-oriented transport:TCP</h2><h3 id="Overviews"><a href="#Overviews" class="headerlink" title="Overviews"></a>Overviews</h3><ul><li><p>point-to-point</p><ul><li>同一个连接中只允许有一个接收者，一个发送者</li><li>不支持多播的形式(multicasting</li></ul></li><li><p>reliable,in-order byte steam</p></li><li><p>pipelined(流水线)</p><ul><li>TCP的congestion,flow control来设置window size</li></ul></li><li><p>full duplex data(全双工数据</p><ul><li>同一连接中可以有双向(bi-directional)数据流</li><li>MSS:最大报文段长度：传输层能够承载的应用层最大数据长度，不包括传输层头部</li></ul></li><li><p>connection-oriented</p><ul><li>数据交换前通过握手(handshaking)来初始化sender,receiver</li></ul></li><li><p>flow controlled</p><ul><li>sender will not overwhelm(覆没) receiver</li></ul></li></ul><h3 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h3><ul><li><p>状态字段</p><ul><li>SYN：建立连接</li><li>FIN：关闭连接</li><li>PSH：有DATA传输</li><li>RST：连接重置</li><li>URG：紧急数据</li></ul></li><li><p>seq number(序列号</p><ul><li>first byte in segment’s data(首个字节数据的编号</li><li>它是通过数据的字节来看的，而不是直接看报文的序列</li><li><p>接收者如何处理乱序的报文？</p><ul><li>留下乱序的字节(放在接收者的buffer中，等待缺失的字节来填补间隙</li><li>keeps out-of-order bytes and waits for missing bytes to fill in the gaps (in practice)</li></ul></li><li><p>接收方与发送方都是随机选择首个sequence number</p></li></ul></li><li><p>acknowledgements number</p><ul><li>不同于rdt3.0</li><li>接收方期待从发送方收到的字节数据的序列号</li><li>cumulative ACK(TCP采用累积确认</li><li><p>example 1</p><ul><li>Host R has received bytes from 0-535from host S, is about to send segment to host S with 536in ACK# field</li></ul></li><li><p>exmaple 2</p><ul><li>R has received 0-535, 900-1000, R’s next segment contain 536in ACK# field</li></ul></li></ul></li><li><p>RTT,timeout</p><ul><li><p>TCP如何设置重传时间？</p><ul><li>一定要大于RTT,但RTT也是一个变量</li><li>太短：会导致过早timeout,很多不必要的重传</li><li>太长：会导致对于报文丢失的反应迟缓</li></ul></li><li><p>如何估计RTT?</p><ul><li><p>SampleRTT</p><ul><li>从报文开始传输到接收到ACK为RTT</li><li>忽略了重传</li><li>SampleRTT也是一个变量所以要去它近几次的平均值，而不只是当前的SampleRTT</li></ul></li><li><p>EstimatedRTT</p><ul><li>EstimatedRTT=(1-α)<em>EstimatedRTT+α</em>SampleRTT</li><li>α为exponential weighted moving average 指数加权移动平均值(EWMA)</li><li>influence of past sample decreases exponentially fast过去样本的<br>影响呈指数级下降</li><li>α = 0.125(typical value</li></ul></li><li><p>how to set timeout?</p><ul><li>大于等于EstimatedRTT</li><li>不能比EstimatedRTT大太多</li><li>time interval:EstimatedRTT+saftey margin</li><li>DevRTT(用于估算：采用RTT偏离来估计RTT的程度</li><li>DevRTT= (1-β)<em>DevRTT+ β</em>|SampleRTT-EstimatedRTT|</li><li>TimeoutInterval= EstimatedRTT+ 4*DevRTT</li><li>如果采样RTT值波动较小，那么DevRTT值也越小，反之亦然</li></ul></li></ul></li></ul></li></ul><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><ul><li><p>TCP基于IP的不可靠服务建立了可靠服务(rdt</p><ul><li>pipelined segments(流水线报文段，与GBN相似</li><li>cumulative acks(累计确认</li><li>single retransmission timer(单个重传定时器</li></ul></li><li><p>触发重传的事件</p><ul><li>timeout events(超时事件</li><li>duplicate acks(冗余ACK</li></ul></li><li><p>TCP 发送方三个重要事件</p><ul><li><p>收到app层发送来的数据</p><ul><li>创建带有序列号的报文段</li><li>序列号是报文段的字节流中的第一个字节</li><li>timer放在最早未被确认的报文那里</li></ul></li><li><p>timeout,超时</p><ul><li>重传导致超时事件的报文</li><li>重启timer</li></ul></li><li><p>收到ack</p><ul><li>累计确认，滑动窗口</li><li>如果还有未被确认的报文，就需要启动timer</li></ul></li></ul></li><li><p>发送方的重要actions</p><ul><li>NextSeqNum= NextSeqNum+ length(data)</li><li>当超时事件被触发时，仅重传最小序列号，未被确认的数据包</li><li>上一点与GBN不同，当GBN协议重传最小序列号及其之后所有未被确认的数据</li></ul></li><li><p>快速重传</p><ul><li>丢包一般是通过冗余的ACK来检测到</li><li>当报文出现丢失时，就可能会有很多冗余的ACKs</li><li>如果发送方收到了三个相同的ACKs,那么就不用等到超时，立刻进行重传</li></ul></li><li><p>需要注意的问题</p><ul><li>seqNum与Ack都是以字节数为单位，所以ack的时候不能跳着确认，只能确认最大的连续收到的包，否则发送端就以为全部收到了，收到的乱序的包是放在接收者的buffer中等待</li><li>当发送方收到ack=n时，会认为前面的包都收到了。所以如果发送了两个ack，但更小的ack没收到，也不需要重传</li><li>当接收方收到了乱序的报文时，会立即发送冗余的ACK，指明下一个期待的报文编号</li><li>累计确认类似于GBN</li><li>接收方缓存乱序包类似于SR</li></ul></li></ul><h3 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h3><ul><li>发送方的速率应当慢于接收方交付给应用层的速度</li><li>接收方控制着发送方，所以发送方才不会传输太多太快覆没接收方的Buffer</li><li>LastByteRead:应用层从接收方缓存中读取的最新一个字节的编号</li><li>LastByteRcvd:到达接收方缓存最新字节数据的编号</li><li>LastByteRcvd-LastByteRead&lt;=RcvBuffer</li><li>rwnd:接收者缓存中的空闲空间；rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]</li><li>RcvBuffer通过socket option来设置</li><li>接收者通过接收者的rwnd值来限制unacked包的数量，保证了接收者buffer不会overflow</li></ul><h2 id="transport-layer-services"><a href="#transport-layer-services" class="headerlink" title="transport-layer services"></a>transport-layer services</h2><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><ul><li>提供app processes间的物理连接</li><li>send side:将app层的messages，分成segments再传给network layer</li><li>rcv side:重组segments为messages,传递给app layer</li></ul><h3 id="transport-vs-network-layer"><a href="#transport-vs-network-layer" class="headerlink" title="transport vs network layer"></a>transport vs network layer</h3><ul><li><p>传输层</p><ul><li>逻辑连接建立在进程之间</li><li>依赖，增强了 network layer的服务</li></ul></li><li><p>网络层</p><ul><li>主机间的逻辑连接</li><li>best-effort delievery</li><li>无法保证报文传输的顺序和数据的完整性</li><li>IP是一个不可靠服务</li><li>由传输协议提供的服务通常受到底层网络层协议（延迟或带宽）的服务模型的约束，一些服务不包括在内，例如， 可靠的数据传输服务</li></ul></li></ul><h3 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h3><ul><li><p>reliable, in-order TCP</p><ul><li>data delivery</li><li>error checking</li><li>flow control</li><li>congestion control</li><li>connection setup</li></ul></li><li><p>unreliable,unordered UDP</p><ul><li>data delivery</li><li>error checking</li></ul></li><li><p>services not available</p><ul><li>delay guarantees</li><li>bandwidth guarantees</li></ul></li></ul><h2 id="multiplexing-and-demutiplexing-多路复用与多路分解"><a href="#multiplexing-and-demutiplexing-多路复用与多路分解" class="headerlink" title="multiplexing and demutiplexing(多路复用与多路分解"></a>multiplexing and demutiplexing(多路复用与多路分解</h2><h3 id="multiplexing-at-sender：处理不同套接字的数据，增加transport-header-为了后面用于多路分解"><a href="#multiplexing-at-sender：处理不同套接字的数据，增加transport-header-为了后面用于多路分解" class="headerlink" title="multiplexing at sender：处理不同套接字的数据，增加transport header(为了后面用于多路分解"></a>multiplexing at sender：处理不同套接字的数据，增加transport header(为了后面用于多路分解</h3><h3 id="demultiplexing-at-receiver：-利用header-info将接收到的报文发送到正确的套接字中"><a href="#demultiplexing-at-receiver：-利用header-info将接收到的报文发送到正确的套接字中" class="headerlink" title="demultiplexing at receiver： 利用header info将接收到的报文发送到正确的套接字中"></a>demultiplexing at receiver： 利用header info将接收到的报文发送到正确的套接字中</h3><h3 id="多路分解中，主机利用IP地址和端口号将报文指向合适的套接字"><a href="#多路分解中，主机利用IP地址和端口号将报文指向合适的套接字" class="headerlink" title="多路分解中，主机利用IP地址和端口号将报文指向合适的套接字"></a>多路分解中，主机利用IP地址和端口号将报文指向合适的套接字</h3><h3 id="Port-number"><a href="#Port-number" class="headerlink" title="Port number"></a>Port number</h3><ul><li>port number是一个16-bit的数字,from 0 to 65535</li><li>0 to 1023 well-known port numbers</li><li>1024 to 65535 dynamic and/or private ports</li></ul><h3 id="UDP-socket-identified"><a href="#UDP-socket-identified" class="headerlink" title="UDP socket identified:"></a>UDP socket identified:</h3><ul><li>dest IP</li><li>dest Port</li></ul><h3 id="TCP-socket-identified"><a href="#TCP-socket-identified" class="headerlink" title="TCP socket identified:"></a>TCP socket identified:</h3><ul><li>dest IP</li><li>dest Port</li><li>source IP</li><li>Source Port</li></ul><h3 id="今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程"><a href="#今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程" class="headerlink" title="今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程"></a>今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程</h3><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li><p>best effort service</p><ul><li>lost</li><li>delivered out-of-order to app</li></ul></li><li><p>connectionless</p><ul><li>sender,receiver之间没有握手</li><li>每个UDP报文都独立于其他</li></ul></li><li><p>used in</p><ul><li>DNS</li><li>RIP(Routing Information Protocol</li><li>SNMP(Simple Network Management Protocol</li><li>streaming multimedia apps(loss tolerant,rate sensitive</li></ul></li><li><p>reliable transfer over UDP</p><ul><li>possible but a nontrivial(艰巨) task</li><li>add reliability at application layer (adding acknowledgment and retransmission mechanisms)</li><li>application-specific error recovery</li></ul></li></ul><h3 id="为何会有UDP的存在"><a href="#为何会有UDP的存在" class="headerlink" title="为何会有UDP的存在"></a>为何会有UDP的存在</h3><ul><li>no congestion control：UDP速度快，很好的适用于real-time applications</li><li>没有建立连接：减少延迟</li><li>sender,receiver没有连接状态</li><li><p>更小的header size</p><ul><li>TCP: typical 20 bytes</li><li>UDP:8 bytes</li></ul></li></ul><h3 id="Segment-header"><a href="#Segment-header" class="headerlink" title="Segment header"></a>Segment header</h3><ul><li>每个字段都是2 bytes</li><li>source port</li><li>dest port</li><li>length(including header</li><li>checksum</li></ul><h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><ul><li>goal:检验是传输的报文中是否存在错误</li><li><p>sender</p><ul><li>将包括头部字段的报文内容视为16-bit整数的序列</li><li>先带循环进位累加所有序列</li><li>累加结果再求反码</li><li>checksum被放在udp的checksum field</li></ul></li><li><p>receiver</p><ul><li>将所有的16-Bit加起来，包括checksum</li><li>查看结果是否等于1111111111111111</li></ul></li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li>UDP并不会恢复错误</li><li>能够检测到所有1-bit的错误，但是无法检测2-bits的错误</li><li>Some implementations of UDP simply discard the damaged segment; others pass the damaged segment with a warning</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哲学家就餐问题详解</title>
      <link href="/2019/04/14/deadlock-problem/"/>
      <url>/2019/04/14/deadlock-problem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支叉子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的叉子，只有在他拿到两支叉子时才能进餐。进餐完毕，放下叉子又继续思考。</p></blockquote><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>题目中明确不允许死锁的发生，所以排除无为而治的方法（鸵鸟算法）与死锁检测。</p><h4 id="静态方法（死锁预防）"><a href="#静态方法（死锁预防）" class="headerlink" title="静态方法（死锁预防）"></a>静态方法（死锁预防）</h4><p><strong>互斥：</strong> 需要六把叉子或者是吃饭的时候共享叉子，与题意不符。</p><p><strong>保持占有：</strong> 一次性拿两把叉子。</p><p><strong>抢占：</strong> 不符合哲学家的身份。</p><p><strong>设定资源访问顺序：</strong> 假设第一个哲学家年龄最大，那么第二个和第五个哲学家就要让他先吃。</p><h4 id="动态方法（死锁避免）"><a href="#动态方法（死锁避免）" class="headerlink" title="动态方法（死锁避免）"></a>动态方法（死锁避免）</h4><p>采用银行家算法：哲学家在每次拿动叉子的时候，先进行判断是否会出现死锁，如果可能出现，哲学家就不拿叉子。</p><h3 id="解题伪代码"><a href="#解题伪代码" class="headerlink" title="解题伪代码"></a>解题伪代码</h3><h4 id="方法0"><a href="#方法0" class="headerlink" title="方法0"></a>方法0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semophore fork[5]=&#123;1&#125;;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">void philosopher(int i)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        think();</span><br><span class="line">        wait(fork[i]);</span><br><span class="line">        wait(fork[(i+1) mod 5])</span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[i]);</span><br><span class="line">        signal(fork[(i+1) mod 5])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line">     parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法可以保证不会有两位相邻的哲学家同时进餐。但是如果五位哲学家同时拿走了右边的叉子，他们每一个人都将会因为没有筷子而无期限的等待，造成思锁问题。</p><hr><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>思路：至多只允许四位哲学家就餐，由鸽笼原理可以得到至少有一位哲学家能够就餐，所以不会发生死锁。这时，需要引入新的信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semophore fork[5]=&#123;1&#125;;</span><br><span class="line">semophore room=4;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">void philosopher(int i)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        think();</span><br><span class="line">        wait(room);</span><br><span class="line">        wait(fork[i]);</span><br><span class="line">        wait(fork[(i+1) mod 5])</span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[i]);</span><br><span class="line">        signal(fork[(i+1) mod 5])</span><br><span class="line">        signal(room)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line">     parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>思路：仅当哲学家左右的筷子同时拿起时才允许进餐（一次性请求全部的资源且不允许抢占）。这时，需要引入一个信号量mutex来对取左边叉子和右边叉子时进行互斥保护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=1;</span><br><span class="line">semophore fork[5]=&#123;1&#125;;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">void philosopher(int i)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        think();</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(fork[i]);</span><br><span class="line">        wait(fork[(i+1) mod 5])</span><br><span class="line">        signal(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[i]);</span><br><span class="line">        signal(fork[(i+1) mod 5])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line">     parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p>思路：设置资源访问顺序，引入两个信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">semophore fork[5]=&#123;1&#125;;</span><br><span class="line">semaphore s1=0,s2=0;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">void philosopher(int i)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        think();</span><br><span class="line">        if((i mod 5)==1)&#123;</span><br><span class="line">            wait(s1);</span><br><span class="line">        &#125;</span><br><span class="line">        if((i mod 5)==4)&#123;</span><br><span class="line">            wait(s2);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(fork[i]);</span><br><span class="line">        wait(fork[(i+1) mod 5])</span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[i]);</span><br><span class="line">        signal(fork[(i+1) mod 5])</span><br><span class="line"></span><br><span class="line">        if((i mod 5)==0)&#123;</span><br><span class="line">            signal(s1);</span><br><span class="line">            signal(s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line">     parbegin(philosopher(0),philosopher(1)，philosopher(2)，philosopher(3)，philosopher(4))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="方法4（银行家算法）"><a href="#方法4（银行家算法）" class="headerlink" title="方法4（银行家算法）"></a>方法4（银行家算法）</h4>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deadlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个常见的python2与python3的兼容问题</title>
      <link href="/2019/04/08/bug-compatibility/"/>
      <url>/2019/04/08/bug-compatibility/</url>
      
        <content type="html"><![CDATA[<ol><li><p>字符编码类型</p><ul><li>python2默认使用ascii字符编码,但因为ascii只支持数百个字符,不能灵活地满足非英文字符,所以p2也同时支持unicode。但是这样也多了一些标识和转换的麻烦。</li><li>python3统一使用unicode字符,节省了开发者时间。</li></ul></li></ol><h4 id="兼容技巧"><a href="#兼容技巧" class="headerlink" title="兼容技巧"></a>兼容技巧</h4><ol><li>字符串赋值之前均使用前缀u</li><li>引入unicode_literals</li></ol><hr><ol start="2"><li><p>导入模块的路径搜索方式</p><ul><li>python2导入模块时首先会搜索到当前目录(cwd),若没有,则搜索环境变量路径.这一特性会给开发者带来许多困扰,尤其是自定义模块与系统模块重名的时侯。</li><li>python3仅会搜索环境变量路径,当你需要搜索自定义模块时,你可以在包管理模式下将项目路径加入到环境变量中,然后再使用绝对路径和相对路径的方式导入。</li></ul></li></ol><h4 id="兼容技巧-1"><a href="#兼容技巧-1" class="headerlink" title="兼容技巧"></a>兼容技巧</h4><ol><li>统一使用绝对路径进行自定义模块导入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">path=os.path.abspath()</span><br><span class="line">sys.path.append(path)</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是使用python2，则可以直接将要导入的文件夹（包）放到当前目录下。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask jinja2 UnicodeDecodeError 解决方法</title>
      <link href="/2019/04/08/bug-flask/"/>
      <url>/2019/04/08/bug-flask/</url>
      
        <content type="html"><![CDATA[<p><strong>在python2中,当有中文传递给jinja2模板会报如下错误:</strong></p><blockquote><p>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe6 in position 0: ordinal not in range(128)</p></blockquote><p>这个时侯单单在字符串前加u表示为unicode字符已经没有用了，而是需要加上一段代码来搞定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys #导入sys模块</span><br><span class="line"></span><br><span class="line">reload(sys) #在之前import进来时,setdefaultencoding函数在被系统调用后删除了,所以必须重新加载此模块</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;) #修改默认编码方式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CBC翻转字节攻击</title>
      <link href="/2019/03/16/sql4/"/>
      <url>/2019/03/16/sql4/</url>
      
        <content type="html"><![CDATA[<h4 id="知识点-AES的CBC模式加密"><a href="#知识点-AES的CBC模式加密" class="headerlink" title="知识点:AES的CBC模式加密"></a>知识点:AES的CBC模式加密</h4><h5 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程:"></a>加密过程:</h5><blockquote><p>IV:用于随机化加密的字符串<br><br>            ciphertext_0=Encrypt(Plaintext XOR IV)只用于第一组块<br><br>            ciphertext_n=Encrypt(Plaintext XOR Ciphertext_N-1)用于除第一组之外的模块</p></blockquote><p><figure class="figure"><img src="https://i.loli.net/2018/09/12/5b98dc5c44de5.jpg" alt="1.png"><figcaption class="figure__caption">1.png</figcaption></figure></p><hr><h5 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程:"></a>解密过程:</h5><blockquote><p>plaintext_0=Decrpt(Ciphertext) XOR IV 只用于第一组块<br><br>    plaintext_n=Decrpt(Ciphertext) XOR Ciphertext_n-1</p></blockquote><p><figure class="figure"><img src="https://i.loli.net/2018/09/12/5b98dc5c63805.jpg" alt="2.png"><figcaption class="figure__caption">2.png</figcaption></figure></p><hr><h4 id="CBC攻击"><a href="#CBC攻击" class="headerlink" title="CBC攻击"></a>CBC攻击</h4><p><strong>攻击发生在解密过程中,实质上就是通过更改上一块的内容,来间接修改明文中的内容,你在密文中改变的字节,只会影响到在下一明文当中,具有相同偏移量的字节.因此,进行cbc攻击仅影响到两个块.<br>主要用途:体现在不知道加密密钥的情况下,通过修改密文,可以间接修改明文</strong></p><p><figure class="figure"><img src="https://i.loli.net/2018/09/12/5b98dd24bba15.jpg" alt="3.png"><figcaption class="figure__caption">3.png</figcaption></figure></p><h4 id="实际应用-Bugku-login4"><a href="#实际应用-Bugku-login4" class="headerlink" title="实际应用:Bugku-login4"></a>实际应用:Bugku-login4</h4><p><a href="http://123.206.31.85:49168/" target="_blank" rel="noopener">login4</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
