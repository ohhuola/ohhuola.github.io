<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Security Learning</title>
	<link rel="stylesheet" href="/css/style.css">
	
      <link rel="alternate" href="/atom.xml" title="Security Learning" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/categories" class="header__link">Categories</a>
			
		</nav>
		<h1 class="header__title"><a href="/">Security Learning</a></h1>
		<h2 class="header__subtitle">on own time</h2>
	</header>

	<main>
		<article>
	
		<h1></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-04-29</span><br>
		
		
	</div>

	

	
		<h1 id="Transport-layer"><a href="#Transport-layer" class="headerlink" title="Transport layer"></a>Transport layer</h1><h2 id="可靠传输的原理"><a href="#可靠传输的原理" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h2><h3 id="不可靠信道的特征将会决定可靠传输协议的复杂性"><a href="#不可靠信道的特征将会决定可靠传输协议的复杂性" class="headerlink" title="不可靠信道的特征将会决定可靠传输协议的复杂性"></a>不可靠信道的特征将会决定可靠传输协议的复杂性</h3><h3 id="rdt"><a href="#rdt" class="headerlink" title="rdt"></a>rdt</h3><ul>
<li>只考虑单向的数据传输</li>
<li>使用finite state machine来描述sender,receiver的状态</li>
<li><p>rdt1.0</p>
<ul>
<li><p>只考虑最简单的情况</p>
<ul>
<li>没有bit error</li>
<li>没有loss packets</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt2.0</p>
<ul>
<li><p>可能会发生位的翻转(flip bits)</p>
<ul>
<li>依然假设包抵达receiver时是有序的，没有丢包的</li>
<li>使用校验和(checksum)来检测bit error</li>
<li><p>问题：如何恢复错误？</p>
<ul>
<li><p>receiver会发送两种包</p>
<ul>
<li>ACKs</li>
<li><p>NAKs</p>
<ul>
<li>告诉发送者包有错误</li>
<li>retransmit重传包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt2.0的新机制</p>
<ul>
<li>error detection</li>
<li>feedback (control msg)</li>
<li>retransmission</li>
</ul>
</li>
<li><p>还采用了stop and wait的机制</p>
<ul>
<li>当发送者发送了一个包后就会等待接受者的响应</li>
</ul>
</li>
<li><p>如果ACK/NAK损坏了呢？</p>
<ul>
<li>介绍一种新的sender-to-receiver packet</li>
<li>增加checksum来让发送者检测和恢复，但对丢包无效</li>
<li>发送者在接受到乱码的ACK/NAK的包时重传当前的数据</li>
</ul>
</li>
<li><p>对于第三种方法，介绍冗余的数据包(duplicate packets)</p>
<ul>
<li>接受者不知道发送者是否正确的接受了ACK/NAK包</li>
<li>因此不能知道到达的数据包时新的数据还是重传的</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>为每一个包加上sequence number(序号)</li>
<li>只需要添加1-bit的序列号就行了</li>
<li>上述就是rdt2.1</li>
<li>当ack包丢失时，rdt2.1会造成死锁的问题</li>
</ul>
</li>
<li><p>rdt2.2 NAK free</p>
<ul>
<li>接受者发送上一个正确的包的ACK</li>
<li>为ACK包也加上序号，表明是哪一个包的ACK</li>
<li>冗余的ACK会导致与NAK相同的动作：让发送者重传当前的包</li>
<li>可以解决rdt2.1的死锁问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt3.0(alternating-bit protocol)比特交替协议</p>
<ul>
<li>新的假设：data,ACKs可能会丢包，校验和，序列，ACKs,重传还不够帮助检测丢包</li>
<li><p>approach</p>
<ul>
<li>sender等待ACK合理的时间</li>
<li>如果没有接收到ACK就重传</li>
<li><p>如果ACK的包只是延迟了</p>
<ul>
<li>重传就会使接收方收到冗余数据</li>
<li>接收者一定要标明ACK的序号</li>
</ul>
</li>
<li><p>需要countdown timer倒数计时器</p>
<ul>
<li>发送者是在传输数据包时就启动计时器，在收到正确的ACK报文时停止计时器</li>
</ul>
</li>
</ul>
</li>
<li><p>即使是收到了损坏的或者序列号不正确的ACK包，也不重传，只在超时时重传并且重置计时器</p>
</li>
<li>rdt3.0性能非常的差stinks,因为一次就传输一个包并且开始等待。stop-and-wait会限制物理资源的使用</li>
<li>rdt3.0可以不需要ack的序列号，因为序列号如果不对，则接收方将直接忽略，只有等到超时，且没有接收到正确的ack时，才会重传。</li>
<li>RTT是不算传输时间的</li>
</ul>
</li>
<li><p>改善：Pipelined protocols(流水线协议)</p>
<ul>
<li>允许发送者有多个，在传输中，未被确认的包</li>
<li>sequence numbers需要增加</li>
<li>发送者/接收者处需要有buffer,来存储已发送但未被确认的包</li>
</ul>
</li>
<li><p>两种常用的 pipelined protocols</p>
<ul>
<li><p>Go-Back-N,（GBN,回退N步</p>
<ul>
<li>允许流水线中存在N个未被确认的数据包</li>
<li><p>接收者采用累计确认(cumulative ack)</p>
<ul>
<li>如果接收到的包的序列号与累计确认值有gap,那么就不会接收这个包</li>
</ul>
</li>
<li><p>最早未被确认的数据维护一个定时器</p>
</li>
<li>当计时器过期时。需要重传所有的数据包</li>
</ul>
</li>
<li><p>Selective Repeat(SR,选择重传</p>
<ul>
<li>同样允许流水线中存在N个未被确认的数据包</li>
<li>接收者是独立确认每一个包</li>
<li>每个未确认的数据包维护一个定时器</li>
<li>当timer过期时，仅仅重传未被确认的数据包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go Back N"></a>Go Back N</h3><ul>
<li><p>window size N</p>
<ul>
<li>流水线中允许连续未被确认包(也可以是未发送的)的最大数量</li>
</ul>
</li>
<li><p>send_base</p>
<ul>
<li>最早未被确认的包的序列号</li>
</ul>
</li>
<li><p>nextseqnum</p>
<ul>
<li>最小的未被使用的序列号</li>
</ul>
</li>
<li><p>数据包的数量不允许是无限的，因为flow control和congestion control</p>
</li>
<li>k-bits seq #，tcp是有32-bit的序列号</li>
<li>当sender接收到ACK之后滑动窗口</li>
<li><p>GBN 发送者必须响应的三种事件</p>
<ul>
<li><p>被应用层调用，首先判断nextseqnum是否大于seq_base+N,这代表着window是否已满</p>
<ul>
<li><p>若满</p>
<ul>
<li>将数据返回给应用层</li>
</ul>
</li>
<li><p>未满</p>
<ul>
<li>创建数据包，发送</li>
</ul>
</li>
</ul>
</li>
<li><p>收到ACK，ACK(n)</p>
<ul>
<li>序列号n即之前的所有数据包都已经被确认了</li>
<li>可能会收到冗余的数据包</li>
</ul>
</li>
<li><p>超时事件,timeout(n)</p>
<ul>
<li>重传序列号为n,以及更高序列号的包</li>
</ul>
</li>
</ul>
</li>
<li><p>GBN 接收者</p>
<ul>
<li><p>始终发送序列号最高（及最近发生）的正确接收的数据包的ACK</p>
<ul>
<li>可能会造成冗余的ACK‘</li>
</ul>
</li>
<li><p>对于乱序的包，一律丢掉（丢掉所有损坏，以及不是期待编号的包</p>
</li>
<li>sender有buffer,但是receiver没有</li>
</ul>
</li>
</ul>
<h3 id="Selective-Repeat"><a href="#Selective-Repeat" class="headerlink" title="Selective Repeat"></a>Selective Repeat</h3><ul>
<li>GBN的问题：如果带宽延迟和窗口大小较大会导致很多包重传</li>
<li>只重传那些未确认的包</li>
<li><p>发送者</p>
<ul>
<li>也使用window，N个连续的序列号可用</li>
<li>用于已发送，但未确认的包</li>
</ul>
</li>
<li><p>接收者</p>
<ul>
<li>独立的确认所有被正确接收的包</li>
<li>缓存接收到的包，以便将其有序的发送给上层</li>
</ul>
</li>
<li><p>接收者与发送者都有窗口</p>
<ul>
<li><p>sender</p>
<ul>
<li>当有来自上层的数据时，如果有可用的序列号，则发送包</li>
<li>timeout(n),重发包n，并且重启timer</li>
<li><p>ACK(n) in [sendbase,sendbase+n-1]</p>
<ul>
<li>标志着标志n被接受了</li>
<li>如果n是序列号最小的未确认的包，则接收后需要将窗口移动到下一个未确认包的序列上</li>
</ul>
</li>
</ul>
</li>
<li><p>receiver</p>
<ul>
<li><p>pkt n in [rcvbase,rcvbase+N-1]</p>
<ul>
<li>send ACK(n)</li>
<li><p>如果out-of-order</p>
<ul>
<li>则放入到buffer中，不做窗口移动</li>
</ul>
</li>
<li><p>如果in-order</p>
<ul>
<li>依旧是放入到buffer中去，只不过还要移动窗口，到下一个未被接收(not-yet-received)的包</li>
</ul>
</li>
</ul>
</li>
<li><p>pkt n in [rcvbase-N,rcvbase-1]</p>
<ul>
<li>send ACK(n)</li>
</ul>
</li>
<li><p>otherwise</p>
<ul>
<li>ignore</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SR的缺点</p>
<ul>
<li>当接收到in-order的包的时候，receiver方无法判断是重传的包，还是新数据，它在这两种情况下会做出相同的反应：放入buffer,并移动窗口</li>
</ul>
</li>
</ul>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><ul>
<li><p>Checksum(first rdt 2.0</p>
<ul>
<li>用于检测传输包是否有bit errors</li>
</ul>
</li>
<li><p>Acknowledgment(first rdt 2.0</p>
<ul>
<li>由接收方传给发送方，表明包已经被正确的接收</li>
</ul>
</li>
<li><p>Negative Acknowledgment (first rdt 2.0</p>
<ul>
<li>由接收方传给发送方，表明包未被正确的接收</li>
</ul>
</li>
<li><p>Sequence Number(first rdt 2.1</p>
<ul>
<li>接收数据包中序列号的gap或冗余，用来表明包的丢失或冗余</li>
</ul>
</li>
<li><p>Timer(first rdt 3.0</p>
</li>
<li><p>Window,pipeling(first rdt 3.1</p>
<ul>
<li>允许多个包被传输且不被ack，发送者的效率高于stop-and-wait的模式</li>
<li>window size由接收者的能力，buffer,level of congestion in the network决定</li>
</ul>
</li>
</ul>
<h2 id="Connection-oriented-transport-TCP"><a href="#Connection-oriented-transport-TCP" class="headerlink" title="Connection-oriented transport:TCP"></a>Connection-oriented transport:TCP</h2><h3 id="Overviews"><a href="#Overviews" class="headerlink" title="Overviews"></a>Overviews</h3><ul>
<li><p>point-to-point</p>
<ul>
<li>同一个连接中只允许有一个接收者，一个发送者</li>
<li>不支持多播的形式(multicasting</li>
</ul>
</li>
<li><p>reliable,in-order byte steam</p>
</li>
<li><p>pipelined(流水线)</p>
<ul>
<li>TCP的congestion,flow control来设置window size</li>
</ul>
</li>
<li><p>full duplex data(全双工数据</p>
<ul>
<li>同一连接中可以有双向(bi-directional)数据流</li>
<li>MSS:最大报文段长度：传输层能够承载的应用层最大数据长度，不包括传输层头部</li>
</ul>
</li>
<li><p>connection-oriented</p>
<ul>
<li>数据交换前通过握手(handshaking)来初始化sender,receiver</li>
</ul>
</li>
<li><p>flow controlled</p>
<ul>
<li>sender will not overwhelm(覆没) receiver</li>
</ul>
</li>
</ul>
<h3 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h3><ul>
<li><p>状态字段</p>
<ul>
<li>SYN：建立连接</li>
<li>FIN：关闭连接</li>
<li>PSH：有DATA传输</li>
<li>RST：连接重置</li>
<li>URG：紧急数据</li>
</ul>
</li>
<li><p>seq number(序列号</p>
<ul>
<li>first byte in segment’s data(首个字节数据的编号</li>
<li>它是通过数据的字节来看的，而不是直接看报文的序列</li>
<li><p>接收者如何处理乱序的报文？</p>
<ul>
<li>留下乱序的字节(放在接收者的buffer中，等待缺失的字节来填补间隙</li>
<li>keeps out-of-order bytes and waits for missing bytes to fill in the gaps (in practice)</li>
</ul>
</li>
<li><p>接收方与发送方都是随机选择首个sequence number</p>
</li>
</ul>
</li>
<li><p>acknowledgements number</p>
<ul>
<li>不同于rdt3.0</li>
<li>接收方期待从发送方收到的字节数据的序列号</li>
<li>cumulative ACK(TCP采用累积确认</li>
<li><p>example 1</p>
<ul>
<li>Host R has received bytes from 0-535from host S, is about to send segment to host S with 536in ACK# field</li>
</ul>
</li>
<li><p>exmaple 2</p>
<ul>
<li>R has received 0-535, 900-1000, R’s next segment contain 536in ACK# field</li>
</ul>
</li>
</ul>
</li>
<li><p>RTT,timeout</p>
<ul>
<li><p>TCP如何设置重传时间？</p>
<ul>
<li>一定要大于RTT,但RTT也是一个变量</li>
<li>太短：会导致过早timeout,很多不必要的重传</li>
<li>太长：会导致对于报文丢失的反应迟缓</li>
</ul>
</li>
<li><p>如何估计RTT?</p>
<ul>
<li><p>SampleRTT</p>
<ul>
<li>从报文开始传输到接收到ACK为RTT</li>
<li>忽略了重传</li>
<li>SampleRTT也是一个变量所以要去它近几次的平均值，而不只是当前的SampleRTT</li>
</ul>
</li>
<li><p>EstimatedRTT</p>
<ul>
<li>EstimatedRTT=(1-α)<em>EstimatedRTT+α</em>SampleRTT</li>
<li>α为exponential weighted moving average 指数加权移动平均值(EWMA)</li>
<li>influence of past sample decreases exponentially fast过去样本的<br>影响呈指数级下降</li>
<li>α = 0.125(typical value</li>
</ul>
</li>
<li><p>how to set timeout?</p>
<ul>
<li>大于等于EstimatedRTT</li>
<li>不能比EstimatedRTT大太多</li>
<li>time interval:EstimatedRTT+saftey margin</li>
<li>DevRTT(用于估算：采用RTT偏离来估计RTT的程度</li>
<li>DevRTT= (1-β)<em>DevRTT+ β</em>|SampleRTT-EstimatedRTT|</li>
<li>TimeoutInterval= EstimatedRTT+ 4*DevRTT</li>
<li>如果采样RTT值波动较小，那么DevRTT值也越小，反之亦然</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><ul>
<li><p>TCP基于IP的不可靠服务建立了可靠服务(rdt</p>
<ul>
<li>pipelined segments(流水线报文段，与GBN相似</li>
<li>cumulative acks(累计确认</li>
<li>single retransmission timer(单个重传定时器</li>
</ul>
</li>
<li><p>触发重传的事件</p>
<ul>
<li>timeout events(超时事件</li>
<li>duplicate acks(冗余ACK</li>
</ul>
</li>
<li><p>TCP 发送方三个重要事件</p>
<ul>
<li><p>收到app层发送来的数据</p>
<ul>
<li>创建带有序列号的报文段</li>
<li>序列号是报文段的字节流中的第一个字节</li>
<li>timer放在最早未被确认的报文那里</li>
</ul>
</li>
<li><p>timeout,超时</p>
<ul>
<li>重传导致超时事件的报文</li>
<li>重启timer</li>
</ul>
</li>
<li><p>收到ack</p>
<ul>
<li>累计确认，滑动窗口</li>
<li>如果还有未被确认的报文，就需要启动timer</li>
</ul>
</li>
</ul>
</li>
<li><p>发送方的重要actions</p>
<ul>
<li>NextSeqNum= NextSeqNum+ length(data)</li>
<li>当超时事件被触发时，仅重传最小序列号，未被确认的数据包</li>
<li>上一点与GBN不同，当GBN协议重传最小序列号及其之后所有未被确认的数据</li>
</ul>
</li>
<li><p>快速重传</p>
<ul>
<li>丢包一般是通过冗余的ACK来检测到</li>
<li>当报文出现丢失时，就可能会有很多冗余的ACKs</li>
<li>如果发送方收到了三个相同的ACKs,那么就不用等到超时，立刻进行重传</li>
</ul>
</li>
<li><p>需要注意的问题</p>
<ul>
<li>seqNum与Ack都是以字节数为单位，所以ack的时候不能跳着确认，只能确认最大的连续收到的包，否则发送端就以为全部收到了，收到的乱序的包是放在接收者的buffer中等待</li>
<li>当发送方收到ack=n时，会认为前面的包都收到了。所以如果发送了两个ack，但更小的ack没收到，也不需要重传</li>
<li>当接收方收到了乱序的报文时，会立即发送冗余的ACK，指明下一个期待的报文编号</li>
<li>累计确认类似于GBN</li>
<li>接收方缓存乱序包类似于SR</li>
</ul>
</li>
</ul>
<h3 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h3><ul>
<li>发送方的速率应当慢于接收方交付给应用层的速度</li>
<li>接收方控制着发送方，所以发送方才不会传输太多太快覆没接收方的Buffer</li>
<li>LastByteRead:应用层从接收方缓存中读取的最新一个字节的编号</li>
<li>LastByteRcvd:到达接收方缓存最新字节数据的编号</li>
<li>LastByteRcvd-LastByteRead&lt;=RcvBuffer</li>
<li>rwnd:接收者缓存中的空闲空间；rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]</li>
<li>RcvBuffer通过socket option来设置</li>
<li>接收者通过接收者的rwnd值来限制unacked包的数量，保证了接收者buffer不会overflow</li>
</ul>
<h2 id="transport-layer-services"><a href="#transport-layer-services" class="headerlink" title="transport-layer services"></a>transport-layer services</h2><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><ul>
<li>提供app processes间的物理连接</li>
<li>send side:将app层的messages，分成segments再传给network layer</li>
<li>rcv side:重组segments为messages,传递给app layer</li>
</ul>
<h3 id="transport-vs-network-layer"><a href="#transport-vs-network-layer" class="headerlink" title="transport vs network layer"></a>transport vs network layer</h3><ul>
<li><p>传输层</p>
<ul>
<li>逻辑连接建立在进程之间</li>
<li>依赖，增强了 network layer的服务</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>主机间的逻辑连接</li>
<li>best-effort delievery</li>
<li>无法保证报文传输的顺序和数据的完整性</li>
<li>IP是一个不可靠服务</li>
<li>由传输协议提供的服务通常受到底层网络层协议（延迟或带宽）的服务模型的约束，一些服务不包括在内，例如， 可靠的数据传输服务</li>
</ul>
</li>
</ul>
<h3 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h3><ul>
<li><p>reliable, in-order TCP</p>
<ul>
<li>data delivery</li>
<li>error checking</li>
<li>flow control</li>
<li>congestion control</li>
<li>connection setup</li>
</ul>
</li>
<li><p>unreliable,unordered UDP</p>
<ul>
<li>data delivery</li>
<li>error checking</li>
</ul>
</li>
<li><p>services not available</p>
<ul>
<li>delay guarantees</li>
<li>bandwidth guarantees</li>
</ul>
</li>
</ul>
<h2 id="multiplexing-and-demutiplexing-多路复用与多路分解"><a href="#multiplexing-and-demutiplexing-多路复用与多路分解" class="headerlink" title="multiplexing and demutiplexing(多路复用与多路分解"></a>multiplexing and demutiplexing(多路复用与多路分解</h2><h3 id="multiplexing-at-sender：处理不同套接字的数据，增加transport-header-为了后面用于多路分解"><a href="#multiplexing-at-sender：处理不同套接字的数据，增加transport-header-为了后面用于多路分解" class="headerlink" title="multiplexing at sender：处理不同套接字的数据，增加transport header(为了后面用于多路分解"></a>multiplexing at sender：处理不同套接字的数据，增加transport header(为了后面用于多路分解</h3><h3 id="demultiplexing-at-receiver：-利用header-info将接收到的报文发送到正确的套接字中"><a href="#demultiplexing-at-receiver：-利用header-info将接收到的报文发送到正确的套接字中" class="headerlink" title="demultiplexing at receiver： 利用header info将接收到的报文发送到正确的套接字中"></a>demultiplexing at receiver： 利用header info将接收到的报文发送到正确的套接字中</h3><h3 id="多路分解中，主机利用IP地址和端口号将报文指向合适的套接字"><a href="#多路分解中，主机利用IP地址和端口号将报文指向合适的套接字" class="headerlink" title="多路分解中，主机利用IP地址和端口号将报文指向合适的套接字"></a>多路分解中，主机利用IP地址和端口号将报文指向合适的套接字</h3><h3 id="Port-number"><a href="#Port-number" class="headerlink" title="Port number"></a>Port number</h3><ul>
<li>port number是一个16-bit的数字,from 0 to 65535</li>
<li>0 to 1023 well-known port numbers</li>
<li>1024 to 65535 dynamic and/or private ports</li>
</ul>
<h3 id="UDP-socket-identified"><a href="#UDP-socket-identified" class="headerlink" title="UDP socket identified:"></a>UDP socket identified:</h3><ul>
<li>dest IP</li>
<li>dest Port</li>
</ul>
<h3 id="TCP-socket-identified"><a href="#TCP-socket-identified" class="headerlink" title="TCP socket identified:"></a>TCP socket identified:</h3><ul>
<li>dest IP</li>
<li>dest Port</li>
<li>source IP</li>
<li>Source Port</li>
</ul>
<h3 id="今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程"><a href="#今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程" class="headerlink" title="今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程"></a>今天的高性能Web服务器只使用一个进程，并为每个新客户端连接创建一个带有新连接套接字的新线程</h3><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li><p>best effort service</p>
<ul>
<li>lost</li>
<li>delivered out-of-order to app</li>
</ul>
</li>
<li><p>connectionless</p>
<ul>
<li>sender,receiver之间没有握手</li>
<li>每个UDP报文都独立于其他</li>
</ul>
</li>
<li><p>used in</p>
<ul>
<li>DNS</li>
<li>RIP(Routing Information Protocol</li>
<li>SNMP(Simple Network Management Protocol</li>
<li>streaming multimedia apps(loss tolerant,rate sensitive</li>
</ul>
</li>
<li><p>reliable transfer over UDP</p>
<ul>
<li>possible but a nontrivial(艰巨) task</li>
<li>add reliability at application layer (adding acknowledgment and retransmission mechanisms)</li>
<li>application-specific error recovery</li>
</ul>
</li>
</ul>
<h3 id="为何会有UDP的存在"><a href="#为何会有UDP的存在" class="headerlink" title="为何会有UDP的存在"></a>为何会有UDP的存在</h3><ul>
<li>no congestion control：UDP速度快，很好的适用于real-time applications</li>
<li>没有建立连接：减少延迟</li>
<li>sender,receiver没有连接状态</li>
<li><p>更小的header size</p>
<ul>
<li>TCP: typical 20 bytes</li>
<li>UDP:8 bytes</li>
</ul>
</li>
</ul>
<h3 id="Segment-header"><a href="#Segment-header" class="headerlink" title="Segment header"></a>Segment header</h3><ul>
<li>每个字段都是2 bytes</li>
<li>source port</li>
<li>dest port</li>
<li>length(including header</li>
<li>checksum</li>
</ul>
<h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><ul>
<li>goal:检验是传输的报文中是否存在错误</li>
<li><p>sender</p>
<ul>
<li>将包括头部字段的报文内容视为16-bit整数的序列</li>
<li>先带循环进位累加所有序列</li>
<li>累加结果再求反码</li>
<li>checksum被放在udp的checksum field</li>
</ul>
</li>
<li><p>receiver</p>
<ul>
<li>将所有的16-Bit加起来，包括checksum</li>
<li>查看结果是否等于1111111111111111</li>
</ul>
</li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li>UDP并不会恢复错误</li>
<li>能够检测到所有1-bit的错误，但是无法检测2-bits的错误</li>
<li>Some implementations of UDP simply discard the damaged segment; others pass the damaged segment with a warning</li>
</ul>

	

	
		<span class="different-posts"><a href="/2019/04/29/Transport layer/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br>welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2019 Lexie oh | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
