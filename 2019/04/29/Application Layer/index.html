<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>自顶向下计算机网络知识笔记(二) | Security Learning</title>
	<link rel="stylesheet" href="/css/style.css">
	
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/categories" class="header__link">Categories</a>
			
				<a href="/about" class="header__link">About</a>
			
		</nav>
		<h1 class="header__title"><a href="/">Security Learning</a></h1>
		<h2 class="header__subtitle">on own time</h2>
	</header>

	<main>
		<article>
	
		<h1>自顶向下计算机网络知识笔记(二)</h1>
	
	<div class="article__infos">
		<span class="article__date">2019-04-29</span><br>
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/Computer-Network/">Computer Network</a>
			</span><br>
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Notebook/">Notebook</a>
			</span>
		
	</div>

	

	
		<h1 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h1><h2 id="Principles-of-network-applications"><a href="#Principles-of-network-applications" class="headerlink" title="Principles of network applications"></a>Principles of network applications</h2><h3 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h3><ul>
<li><p>Client-server</p>
<ul>
<li><p>server</p>
<ul>
<li>永远在线</li>
<li>固定的IP</li>
<li>Web,FTP,email,Telnet</li>
<li>data center for scaling</li>
</ul>
</li>
<li><p>clients</p>
<ul>
<li>与服务器通信</li>
<li>间断地连接(intermittently)</li>
<li>动态IP</li>
<li>无法直接与彼此通信</li>
</ul>
</li>
</ul>
</li>
<li><p>peer-to-peer</p>
<ul>
<li>没有永远在线的服务器</li>
<li>终端之间直接通信</li>
<li>可收缩性(self-scalability):新的peers带来提供服务的能力和需求</li>
<li>peers间断地连接，改变IP地址</li>
<li>性价比更高(cost effective)</li>
<li><p>主要的挑战</p>
<ul>
<li>ISP Friendly</li>
<li>Security</li>
<li>Incentives(激励)</li>
</ul>
</li>
</ul>
</li>
<li><p>hybrid of client-server and P2P</p>
<ul>
<li><p>及时消息应用</p>
<ul>
<li><p>中心服务</p>
<ul>
<li>用户在联机时向中央服务器注册其IP地址</li>
<li>用户联系中央服务器以查找好友的IP地址</li>
</ul>
</li>
<li><p>两个用户之间的聊天是采用P2P</p>
</li>
</ul>
</li>
<li><p>Skype</p>
<ul>
<li>VOIP P2P application</li>
<li>centralized server(中心服务):找到他人的地址</li>
<li>client-client connection:direct(not through server)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul>
<li>同一个主机中，利用进程间通信(IPC)</li>
<li><p>不同主机</p>
<ul>
<li>sending process:创建，发送消息</li>
<li>receiving process:接收消息，响应</li>
</ul>
</li>
<li><p>Define</p>
<ul>
<li>client:初始化通信(client broswer)</li>
<li>server:等待连接，开始会话(web server)</li>
</ul>
</li>
<li><p>P2P也可以定义为client-server</p>
</li>
</ul>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h3 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h3><ul>
<li>进程必须有标识符</li>
<li>IP地址不能作为进程的标识符</li>
<li>标识符包括了IP地址与端口号</li>
</ul>
<h3 id="App-layer协议定义"><a href="#App-layer协议定义" class="headerlink" title="App-layer协议定义"></a>App-layer协议定义</h3><ul>
<li>type of messages exchanged</li>
<li>message syntax(语法),semantics(语义)</li>
<li>rules for when&amp;how processes send&amp;respond to messages</li>
<li>还可以定义为公开协议(open protocols)和私有协议(proprietary protocols)如:skype,QQ,Thunder</li>
</ul>
<h3 id="app需要的传输服务"><a href="#app需要的传输服务" class="headerlink" title="app需要的传输服务"></a>app需要的传输服务</h3><ul>
<li>数据完整性(data integrity)</li>
<li>及时性</li>
<li>吞吐量(Throughput)</li>
<li>安全性</li>
<li>UDP/TCP均不提供timing和throughput保证</li>
</ul>
<h3 id="安全套接层-SSL"><a href="#安全套接层-SSL" class="headerlink" title="安全套接层(SSL)"></a>安全套接层(SSL)</h3><ul>
<li>TCP/UDP还没有加密，所以引入了SSL</li>
<li>能够提供encrypted connection,data integrity,end-point authentication</li>
<li>在应用层实施</li>
<li>SSL是如何工作的？ Ans:SSL将应用层未加密的数据进行了加密之后在传输给TCP套接字，如果想要使用SSL，那么应用程序中必须包含SSL的代码。</li>
</ul>
<h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><h3 id="web-page包括base-HTML-file-和一些referenced-objects"><a href="#web-page包括base-HTML-file-和一些referenced-objects" class="headerlink" title="web page包括base HTML file 和一些referenced objects"></a>web page包括base HTML file 和一些referenced objects</h3><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP(超文本传输协议)"></a>HTTP(超文本传输协议)</h3><ul>
<li><p>步骤</p>
<ul>
<li>客户端初始化TCP连接(创建套接字),port 80</li>
<li>服务器创建TCP连接</li>
<li>HTTP messages(app-layer) 在客户端与服务器之间交换</li>
<li>TCP连接关闭</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>stateless protocol</li>
<li>采用TCP</li>
</ul>
</li>
<li><p>HTTP 连接</p>
<ul>
<li><p>non-persistent连接</p>
<ul>
<li>非持续连接:每一个请求/响应对都使用一个独立的TCP连接.</li>
<li>下载多个objects需要多个连接</li>
<li><p>缺点</p>
<ul>
<li>established and maintained for eachrequested object,</li>
<li>can place a significant burden<br>on the Web server</li>
<li>必须给分配TCP缓冲区，并且必须在客户端和服务器中保留TCP变量</li>
<li>each object suffers a delivery<br>delay of more than two RTTs</li>
</ul>
</li>
</ul>
</li>
<li><p>persistent连接</p>
<ul>
<li>所有的请求/响应对都使用相同的TCP连接.</li>
<li>可以通过客户端，服务器之间的单个TCP连接发送多个对象</li>
<li><p>优点</p>
<ul>
<li>当遇到referenced objects的时候，客户端立刻发送请求</li>
<li>所有的referenced object只需要一个RTT</li>
</ul>
</li>
<li><p>default mode of HTTP uses persistent connections with pipelinling (流水线）</p>
</li>
</ul>
</li>
<li><p>第一次http请求时，请求到一个html file，解析时能够找到引用的对象，进而再次发起请求</p>
</li>
</ul>
</li>
<li><p>Round-trip Time(RTT, 返回时间)</p>
<ul>
<li>一个包从客户端到服务器再返回所需的时间</li>
<li>包括了processing delays,queuing delays, and propagation delays</li>
</ul>
</li>
<li><p>HTTP Respond time</p>
<ul>
<li>一个RTT来初始化TCP连接</li>
<li>一个RTT用于HTTP请求和响应</li>
<li>file transmission time</li>
<li>=2RTT+file transmission time</li>
</ul>
</li>
<li><p>HTTP Request message</p>
<ul>
<li><p>request line</p>
<ul>
<li>method</li>
<li>url</li>
<li>version</li>
</ul>
</li>
<li><p>header lines</p>
</li>
<li>blank lines</li>
<li>body lines</li>
</ul>
</li>
<li><p>HTTP respond message</p>
<ul>
<li><p>status line</p>
<ul>
<li>version</li>
<li>status code</li>
<li>status message(phrase)</li>
</ul>
</li>
<li><p>header lines</p>
</li>
<li>blank lines</li>
<li>body lines</li>
</ul>
</li>
<li><p>Method types</p>
<ul>
<li>GET:</li>
<li>POST:</li>
<li>HEAD:asks server to leave requested object out of response (for debugging)</li>
<li>PUT:uploads file in entity body to the path specified in URL field (web publishing)</li>
<li>DELETE:deletes file specified in the URL field</li>
</ul>
</li>
<li><p>Status code</p>
<ul>
<li>200 OK,request succeeded, requested object later in this msg</li>
<li>301 Moved Permanently,requested object moved, new location specified later in this msg(Location:)</li>
<li>400 Bad Request,request msg not understood by server</li>
<li>404 Not Found,requested document not found on this server</li>
<li>505 HTTP Version Not Supported</li>
</ul>
</li>
<li><p>Cookies</p>
<ul>
<li>To identify users, many Web sites use cookies (HTTP protocol can not do this!)</li>
<li><p>四个组成部分</p>
<ul>
<li>cookie header line of HTTP responsemessage</li>
<li>cookie header line in next HTTP request message</li>
<li>cookie file kept on user’s host, managed by<br>user’s browser</li>
<li>back-end(后端) database at Web site</li>
</ul>
</li>
<li><p>cookie就是在无状态的http上创建了一个用户会话层来携带状态</p>
</li>
</ul>
</li>
<li><p>Web caches(proxy server 代理服务器)</p>
<ul>
<li>目标:不使用原始服务器也能满足客户端的请求</li>
<li><p>使用步骤</p>
<ul>
<li>用户通过设置代理服务器来访问web</li>
<li>浏览器将所有的HTTP请求发送给proxy server</li>
<li>如果请求对象在缓存中则返回</li>
<li>如果不在,缓存就会到原始服务器中去请求对象,然后将其返回给客户端</li>
</ul>
</li>
<li><p>代理服务器既是客户端又是服务器,它通常由ISP安装</p>
</li>
<li><p>出现的原因</p>
<ul>
<li>减少客户端请求的响应时间</li>
<li>reduce traffic on an institution’s access link</li>
</ul>
</li>
</ul>
</li>
<li><p>Conditional GET</p>
<ul>
<li>问题:驻留在Web缓存中的对象的副本可能是陈旧的</li>
<li>目标:允许Web缓存检查对象是否是最新的,如果缓存是最新的版本,那么原始服务器将不会发送对象</li>
<li>web cache通过If-modified-since:<date>在HTTP请求中指定缓存副本的日期</date></li>
<li>origin server：如果缓存的副本是最新的，则response不包含任何对象</li>
</ul>
</li>
</ul>
<h2 id="FTP-the-file-transfer-protocol"><a href="#FTP-the-file-transfer-protocol" class="headerlink" title="FTP(the file transfer protocol)"></a>FTP(the file transfer protocol)</h2><h3 id="client-server-model"><a href="#client-server-model" class="headerlink" title="client/server model"></a>client/server model</h3><ul>
<li>client:初始化传输</li>
<li>server:远程主机</li>
</ul>
<h3 id="connection-TCP"><a href="#connection-TCP" class="headerlink" title="connection(TCP)"></a>connection(TCP)</h3><ul>
<li><p>control connection</p>
<ul>
<li>port 21</li>
<li>浏览远程目录,发送命令</li>
<li>用户会话未过期前control connection 保持开放</li>
<li>out of band带外</li>
</ul>
</li>
<li><p>data connection</p>
<ul>
<li>port 20</li>
<li>当服务器接收到文件传输指令时打开data connection</li>
<li>当传输完一个文件后,服务器就关闭data connection</li>
<li>服务器打开另一个TCP数据连接以传输另一个文件</li>
</ul>
</li>
<li><p>FTP服务器维护“状态”：当前目录，早期验证</p>
</li>
<li>stateful protocol</li>
<li>Why “out-of-band”? Ans: FTP使用了两个并行连接，一个用于发送控制信息，另一个用于发送数据信息。由于控制信息与数据不在同一个TCP连接中传输，所以FTP发送控制信息out-of-band。</li>
</ul>
<h3 id="FTP-Commands"><a href="#FTP-Commands" class="headerlink" title="FTP Commands"></a>FTP Commands</h3><ul>
<li>向control channel发送ASCII text</li>
<li>USER username</li>
<li>PASS password</li>
<li>LIST return list of file in current directory</li>
<li>RETR filename retrieves file</li>
<li>STOR filename stores (puts) file onto remote host</li>
</ul>
<h3 id="FTP-return-code"><a href="#FTP-return-code" class="headerlink" title="FTP return code"></a>FTP return code</h3><ul>
<li>status code and phrase(as in HTTP)</li>
<li>331 username OK, password required</li>
<li>125 data connection already open;transfer starting</li>
<li>425 can’t open data connection</li>
<li>452 Error writing file</li>
</ul>
<h2 id="Electronic-mail"><a href="#Electronic-mail" class="headerlink" title="Electronic mail"></a>Electronic mail</h2><h3 id="three-major-components"><a href="#three-major-components" class="headerlink" title="three major components"></a>three major components</h3><ul>
<li>user agents</li>
<li><p>mail servers</p>
<ul>
<li>mailbox包含用户的incoming messages</li>
<li>message queue包含将要被发送的邮件消息</li>
</ul>
</li>
<li><p>simple mail transfer protocol(SMTP)</p>
<ul>
<li>邮件服务器之间用SMTP协议发送电子邮件</li>
<li>使用TCP传输电子邮件消息，端口25（服务器），持久连接（持久）</li>
<li>直接传输：将服务器（SMTP客户端）发送到接收服务器（SMTP服务器）</li>
<li>消息一定要是7-bit的ASCII码</li>
<li><p>命令与响应的交互</p>
<ul>
<li>commands:ASCII text(HELO,MAIL FROM,RCPT TO,DATA,QUIT</li>
<li>response:status code and phrase</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="comparison-with-HTTP"><a href="#comparison-with-HTTP" class="headerlink" title="comparison with HTTP"></a>comparison with HTTP</h3><ul>
<li>SMTP使用persistent connections, stateful protocol, 7-bit ASCII(MIME), CRLF.CRLF来决定消息的结束</li>
<li><p>similar</p>
<ul>
<li>ASCII command/response</li>
<li>interaction</li>
<li>status code</li>
<li>persistent HTTP与SMTP使用持久连接</li>
</ul>
</li>
<li><p>different</p>
<ul>
<li>HTTP是拉的协议;SMTP是推的协议</li>
<li>SMTP要求每个消息必须是7-bit ASCII格式;HTTP没有要求</li>
<li>HTTP每个对象对应一个HTTP相应要求;SMTP所有对象放在一个消息里</li>
</ul>
</li>
</ul>
<h3 id="mail-message-format"><a href="#mail-message-format" class="headerlink" title="mail message format"></a>mail message format</h3><ul>
<li>类似邮局之间新建传递规则</li>
<li><p>header lines</p>
<ul>
<li>To(required)</li>
<li>From(required)</li>
<li>Subject(optional)</li>
<li>注意 MAIL FROM 是在SMTP中是来自SMTP客户端的消息，用于标识发送到SMTP服务器的邮件的发件人。而From只是邮件中正文的一行。</li>
</ul>
</li>
<li><p>blank line(CRLF)</p>
</li>
<li><p>body(ASCII)</p>
<ul>
<li>只允许ASCII</li>
<li>MIME(多用途互联网邮件扩展)</li>
</ul>
</li>
</ul>
<h3 id="SMTP-发送-存储接收者服务器-push"><a href="#SMTP-发送-存储接收者服务器-push" class="headerlink" title="SMTP:发送/存储接收者服务器(push)"></a>SMTP:发送/存储接收者服务器(push)</h3><h3 id="mail-access-protocol-从服务器检索-pull"><a href="#mail-access-protocol-从服务器检索-pull" class="headerlink" title="mail access protocol:从服务器检索(pull)"></a>mail access protocol:从服务器检索(pull)</h3><ul>
<li><p>POP3:Post Office Protocol -version3(邮局协议版本3),server port 110</p>
<ul>
<li>authorization(认证阶段)</li>
<li>transaction,client</li>
<li>update</li>
<li><p>特点</p>
<ul>
<li>stateless protocol</li>
<li>POP3不会跨会话传送状态信息</li>
<li>“下载并保留”：不同客户端上的消息副本</li>
</ul>
</li>
</ul>
</li>
<li><p>IMAP:Internet Mail Access Protocol(Internet邮件访问协议)</p>
<ul>
<li>stateful protocol</li>
<li>能够管理服务器上的文件,更加的复杂</li>
<li>将所有的消息放在服务器上的一个地方</li>
<li>允许用户组织文件夹中的消息</li>
<li>跨会话保持用户状态（与POP3不同）</li>
</ul>
</li>
<li><p>HTTP</p>
<ul>
<li>user agent is Web browser</li>
</ul>
</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><ul>
<li>distributed database</li>
<li>application-layer-protocol</li>
<li>port 53,using UDP</li>
</ul>
<h3 id="DNS-services：通常被其他应用层协议使用-包括HTTP，SMTP和FTP"><a href="#DNS-services：通常被其他应用层协议使用-包括HTTP，SMTP和FTP" class="headerlink" title="DNS services：通常被其他应用层协议使用 - 包括HTTP，SMTP和FTP"></a>DNS services：通常被其他应用层协议使用 - 包括HTTP，SMTP和FTP</h3><ul>
<li>域名到IP地址的转换</li>
<li>主机别名(host aliasing),获取主机别名对应的规范主机名及主机IP地址</li>
<li>邮件服务器别名</li>
<li>负载分配(load distribution)</li>
</ul>
<h3 id="centralize-DNS的缺点"><a href="#centralize-DNS的缺点" class="headerlink" title="centralize DNS的缺点"></a>centralize DNS的缺点</h3><ul>
<li>单点故障(single point of failure)</li>
<li>流量规模大(traffic volume)</li>
<li>维护成本(maintenance)</li>
<li>无扩展性(doesn’t scale)</li>
<li>远距离的集中式数据库(distant centralized database)</li>
</ul>
<h3 id="分布式层次数据库"><a href="#分布式层次数据库" class="headerlink" title="分布式层次数据库"></a>分布式层次数据库</h3><ul>
<li><p>根DNS服务器(root DNS server)</p>
<ul>
<li>13 root name sever</li>
<li>与本地域名服务器(local name server)直接相连</li>
</ul>
</li>
<li><p>顶级域DNS服务器(TLD, top-level domain)</p>
</li>
<li><p>权威DNS服务器(authoritative DNS sever)</p>
<ul>
<li>organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts</li>
<li>can be maintained by organization (e.g. university, company)themselves or service provider</li>
</ul>
</li>
<li><p>本地DNS服务器(Local DNS name server)</p>
<ul>
<li>不属于分层结构</li>
<li>也叫作默认名称服务器</li>
<li>能够有本地缓存</li>
<li>是像代理一样的角色，发送请求到分层结构</li>
</ul>
</li>
</ul>
<h3 id="Resolution-example"><a href="#Resolution-example" class="headerlink" title="Resolution example"></a>Resolution example</h3><ul>
<li><p>迭代查询(iterated query)</p>
<ul>
<li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</li>
<li>usual method(常用模式)</li>
</ul>
</li>
<li><p>递归查询(recursive query)</p>
<ul>
<li>直接返回一个最终结果给本地DNS服务器</li>
<li>将名称解析的负担放在联系的名称服务器上</li>
<li>层次结构上层的重负荷</li>
<li>如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让本地服务器自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li>
</ul>
</li>
</ul>
<h3 id="DNS-Records"><a href="#DNS-Records" class="headerlink" title="DNS Records"></a>DNS Records</h3><ul>
<li>Resource records(RR) format;(Name,value,Type,TTL)</li>
<li><p>Type=A,标准主机名到IP的映射</p>
<ul>
<li>Name is hostname</li>
<li>Value is IP address</li>
</ul>
</li>
<li><p>Type=NS,域的权威域名服务器</p>
<ul>
<li>Name is domain name(e.g.,foo.com)</li>
<li>Value is hostname of authoritative name server for this domain</li>
</ul>
</li>
<li><p>Type=CNAME,别名对应的规范主机名</p>
<ul>
<li>Name is alias name (别名) for some “canonical”(the real) name (规范名)</li>
<li>Value is canonical name (规范名)</li>
</ul>
</li>
<li><p>Type=MX,别名对应的邮件服务器的规范主机名</p>
<ul>
<li>Name is alias name</li>
<li>Value is canonical name (规范名)of a mail server</li>
</ul>
</li>
</ul>
<h3 id="DNS-protocol-header-section-12-bytes-每个字段是2-bytes"><a href="#DNS-protocol-header-section-12-bytes-每个字段是2-bytes" class="headerlink" title="DNS protocol:header section(12 bytes),每个字段是2 bytes"></a>DNS protocol:header section(12 bytes),每个字段是2 bytes</h3><h3 id="nslookup-Tool-can-send-a-DNS-query-to-any-DNS-server-root-TLD-or-authoritative"><a href="#nslookup-Tool-can-send-a-DNS-query-to-any-DNS-server-root-TLD-or-authoritative" class="headerlink" title="nslookup Tool:can send a DNS query to any DNS server (root, TLD, or authoritative)"></a>nslookup Tool:can send a DNS query to any DNS server (root, TLD, or authoritative)</h3><h3 id="Inserting-records-into-DNS"><a href="#Inserting-records-into-DNS" class="headerlink" title="Inserting records into DNS"></a>Inserting records into DNS</h3><ul>
<li><p>step 1:在域名注册服务机构(DNS registrar)注册域名</p>
<ul>
<li>互联网名称与数字地址分配机构(ICANN,Internet Corporation for Assigned Names and Numbers)授权域名注册服务机构</li>
<li>提供names, IP addresses of 权威域名服务器(包括primary主要的+secondary辅助的)</li>
<li>registrar inserts two RRs into .com TLD server<ol>
<li>(networkutopia.com, dns1.networkutopia.com, NS)//域的权威DNS服务器名称</li>
<li>(dns1.networkutopia.com, 212.212.212.1, A)//主机名到IP映射</li>
</ol>
</li>
</ul>
</li>
<li><p>Step 2:enter your authoritative name server(权威DNS服务器)type A record for <a href="http://www.networkuptopia.com" target="_blank" rel="noopener">www.networkuptopia.com</a>; type MX record for mail.networkutopia.com</p>
</li>
</ul>
<h2 id="P2P-Applications"><a href="#P2P-Applications" class="headerlink" title="P2P Applications"></a>P2P Applications</h2><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><ul>
<li>稀少资源优先(rarest first)</li>
<li>以牙还牙，一个以善意合作为出发点的博弈策略(tit-for-tat</li>
<li>every 30 secs: randomly select another peer, starts sending chunks</li>
</ul>

	

	
		<span class="different-posts"><a href="/2019/04/29/Application Layer/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br>welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2020 Lexie oh | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
